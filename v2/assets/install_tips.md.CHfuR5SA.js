import{_ as a,c as s,o as i,aj as t}from"./chunks/framework.-cddG0Qo.js";const p=JSON.parse('{"title":"Installation Info","description":"","frontmatter":{},"headers":[],"relativePath":"install_tips.md","filePath":"install_tips.md","lastUpdated":null}'),n={name:"install_tips.md"};function o(r,e,l,c,h,d){return i(),s("div",null,[...e[0]||(e[0]=[t(`<h1 id="Installation-Info" tabindex="-1">Installation Info <a class="header-anchor" href="#Installation-Info" aria-label="Permalink to &quot;Installation Info {#Installation-Info}&quot;">​</a></h1><h2 id="ROCm-system-libraries" tabindex="-1">ROCm system libraries <a class="header-anchor" href="#ROCm-system-libraries" aria-label="Permalink to &quot;ROCm system libraries {#ROCm-system-libraries}&quot;">​</a></h2><p>On Linux, AMDGPU.jl queries the location of ROCm libraries through <code>rocminfo</code> by default. If not successful or on Windows, the following standard directories are searched:</p><p>Standard paths:</p><ul><li><p>Linux: <code>/opt/rocm</code>, <code>/usr</code></p></li><li><p>Windows: <code>C:/Program Files/AMD/ROCm/&lt;rocm-version&gt;</code></p></li></ul><p>If you have non-standard path for ROCm, set <code>ROCM_PATH=&lt;path&gt;</code> environment variable before launching Julia. The <code>AMDGPU.versioninfo()</code> function prints the paths of any libraries found.</p><p>Depending on your GPU model and the functionality you want to use, you may have to force the GPU architecture by setting the <code>HSA_OVERRIDE_GFX_VERSION</code> variable to a compatible version.</p><p>You may also have more than one type of GPU, for example a dedicated AMD GPU and an integrated one. In that case use <code>rocminfo</code> to find which device they are and setting <code>HIP_VISIBLE_DEVICES</code> to the specific device you want to use. Otherwise the runtime may crash if it sees two different architectures.</p><h2 id="Extra-Setup-Details" tabindex="-1">Extra Setup Details <a class="header-anchor" href="#Extra-Setup-Details" aria-label="Permalink to &quot;Extra Setup Details {#Extra-Setup-Details}&quot;">​</a></h2><p>List of additional steps that may be needed to take to ensure everything is working:</p><ul><li><p>Make sure your user is in the same group as <code>/dev/kfd</code>, other than <code>root</code>. For example, it might be the <code>render</code> group: <code>crw-rw---- 1 root render 234, 0 Aug 5 11:43 kfd</code> In this case, you can add yourself to it: <code>sudo usermod -aG render username</code></p></li><li><p>ROCm libraries should be in the standard library locations, or in your <code>LD_LIBRARY_PATH</code>.</p></li><li><p>If you get an error message along the lines of <code>GLIB_CXX_... not found</code>, it&#39;s possible that the C++ runtime used to build the ROCm stack and the one used by Julia are different. If you built the ROCm stack yourself this is very likely the case since Julia normally ships with its own C++ runtime. For more information, check out this <a href="https://github.com/JuliaLang/julia/issues/34276" target="_blank" rel="noreferrer">GitHub issue</a>. A quick fix is to use the <code>LD_PRELOAD</code> environment variable to make Julia use the system C++ runtime library, for example: <code>LD_PRELOAD=/usr/lib/libstdc++.so julia</code> Alternatively, you can build Julia from source as described <a href="https://github.com/JuliaLang/julia/blob/master/doc/build/build.md" target="_blank" rel="noreferrer">here</a>. To quickly debug this issue start Julia and try to load a ROCm library: <code>using Libdl Libdl.dlopen(&quot;/opt/rocm/hsa/lib/libhsa-runtime64.so.1&quot;)</code></p></li></ul><p>Once all of this is setup properly, you should be able to do <code>using AMDGPU</code> successfully.</p><p>See the <a href="/v2/tutorials/quickstart#Quick-Start">Quick Start</a> documentation for an introduction to using AMDGPU.jl.</p><h2 id="Preferences" tabindex="-1">Preferences <a class="header-anchor" href="#Preferences" aria-label="Permalink to &quot;Preferences {#Preferences}&quot;">​</a></h2><p>AMDGPU.jl supports setting <a href="https://github.com/JuliaPackaging/Preferences.jl" target="_blank" rel="noreferrer">preferences</a>. Template of <code>LocalPreferences.toml</code> with all options:</p><div class="language-toml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">toml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">AMDGPU</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># If \`true\` (default is \`false\`), eagerly run GC to keep the pool from growing too big.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># GC is triggered during new allocatoins or synchronization points.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">eager_gc = </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Use non-blocking synchronization for all \`AMDGPU.synchronize()\` calls (default is \`true\`).</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">nonblocking_synchronization = </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Memory limit specifies maximum amount of memory in percentages</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># a current Julia process can use.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Default is &quot;none&quot;, which does not apply any limitation.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">hard_memory_limit = </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;none&quot;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Notice a space between the value and percentage sign.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># hard_memory_limit = &quot;80 %&quot;</span></span></code></pre></div><h2 id="Windows-OS-missing-functionality" tabindex="-1">Windows OS missing functionality <a class="header-anchor" href="#Windows-OS-missing-functionality" aria-label="Permalink to &quot;Windows OS missing functionality {#Windows-OS-missing-functionality}&quot;">​</a></h2><p>Windows <strong>does not</strong> yet support <a href="/v2/api/hostcall#Hostcall">Hostcall</a>, which means that some of the functionality does not work, like:</p><ul><li><p>device printing;</p></li><li><p>dynamic memory allocation (from kernels).</p></li></ul><p>These hostcalls are sometimes launched when AMDGPU detects that a kernel might throw an exception, specifically during conversions, like: <code>Int32(1f0)</code>.</p><p>To avoid this, use &#39;unsafe&#39; conversion option: <code>unsafe_trunc(Int32, 1f0)</code>.</p><h2 id="Frequently-Asked-Questions" tabindex="-1">Frequently-Asked-Questions <a class="header-anchor" href="#Frequently-Asked-Questions" aria-label="Permalink to &quot;Frequently-Asked-Questions {#Frequently-Asked-Questions}&quot;">​</a></h2><h3 id="Archlinux" tabindex="-1">Archlinux <a class="header-anchor" href="#Archlinux" aria-label="Permalink to &quot;Archlinux {#Archlinux}&quot;">​</a></h3><p>For the last few ROCM releases we have seen folks run into issue with the distro-provided builds of ROCM and associated tools. <a href="https://github.com/JuliaGPU/AMDGPU.jl/issues/770" target="_blank" rel="noreferrer">#770</a>, <a href="https://github.com/JuliaGPU/AMDGPU.jl/issues/696" target="_blank" rel="noreferrer">#696</a>, <a href="https://github.com/JuliaGPU/AMDGPU.jl/issues/767" target="_blank" rel="noreferrer">#767</a></p><p>Some users have reported success with using the <a href="https://aur.archlinux.org/packages/opencl-amd-dev" target="_blank" rel="noreferrer"><code>opencl-amd-dev</code></a> AUR package.</p>`,25)])])}const m=a(n,[["render",o]]);export{p as __pageData,m as default};
