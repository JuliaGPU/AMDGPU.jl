# copied from CUDAdrv/deps/build.jl

using Libdl

function version_hsa(libpath)
    lib = Libdl.dlopen(libpath)
    sym = Libdl.dlsym(lib, "hsa_system_get_info")
    major_ref = Ref{Cushort}(typemax(Cushort))
    minor_ref = Ref{Cushort}(typemax(Cushort))
    status = ccall(sym, Cint, (Cint, Ptr{Cushort}), 0, major_ref)
    @assert status == 0 "HSA error: $status"
    status = ccall(sym, Cint, (Cint, Ptr{Cushort}), 1, minor_ref)
    @assert status == 0 "HSA error: $status"
    return VersionNumber(major_ref[], minor_ref[])
end

function init_hsa(libpath)
    lib = Libdl.dlopen(libpath)
    sym = Libdl.dlsym(lib, "hsa_init")
    ccall(sym, Cint, ())
end

function shutdown_hsa(libpath)
    lib = Libdl.dlopen(libpath)
    sym = Libdl.dlsym(lib, "hsa_shut_down")
    ccall(sym, Cint, ())
end


## main

const config_path = joinpath(@__DIR__, "ext.jl")
const previous_config_path = config_path * ".bak"

function write_ext(config, path)
    open(path, "w") do io
        println(io, "# autogenerated file, do not edit")
        for (key,val) in config
            println(io, "const $key = $(repr(val))")
        end
    end
end

function read_ext(path)
    config = Dict{Symbol,Any}()
    r = r"^const (\w+) = (.+)$"
    open(path, "r") do io
        for line in eachline(io)
            m = match(r, line)
            if m != nothing
                config[Symbol(m.captures[1])] = eval(Meta.parse(m.captures[2]))
            end
        end
    end
    return config
end

function build_error(reason)
    println("$reason.")
    exit(1)
end

function find_roc_paths()
    paths = split(get(ENV, "LD_LIBRARY_PATH", ""), ":")
    paths = filter(path->path != "", paths)
    paths = map(Base.Filesystem.abspath, paths)
    paths = filter(isdir, paths)
    return paths
end

function find_hsa_library(lib, dirs)
    for dir in dirs
        files = readdir(dir)
        for file in files
            if startswith(basename(file), lib * ".so")
                return joinpath(dir, file)
            end
        end
    end
end

function main()
    ispath(config_path) && mv(config_path, previous_config_path; force=true)
    config = Dict{Symbol,Any}(:configured => false)
    write_ext(config, config_path)


    ## discover stuff

    # check that we're running Linux
    if !Sys.islinux()
        build_error("Not running Linux, which is the only platform currently supported by the ROCm Runtime.")
    end

    roc_dirs = find_roc_paths()

    config[:libhsaruntime_path] = find_hsa_library("libhsa-runtime64", roc_dirs)
    if config[:libhsaruntime_path] == nothing
        build_error("Could not find HSA runtime library")
    end
    config[:libhsaruntime_vendor] = "AMD"

    # initializing the library isn't necessary, but flushes out errors that otherwise would
    # happen during `version` or, worse, at package load time.
    status = init_hsa(config[:libhsaruntime_path])
    if status != 0
        build_error("Initializing HSA runtime failed with code $status.")
    end

    config[:libhsaruntime_version] = version_hsa(config[:libhsaruntime_path])

    # also shutdown just in case
    status = shutdown_hsa(config[:libhsaruntime_path])
    if status != 0
        build_error("Shutdown of HSA runtime failed with code $status.")
    end

    config[:configured] = true


    ## (re)generate ext.jl

    if isfile(previous_config_path)
        previous_config = read_ext(previous_config_path)

        if config == previous_config
            mv(previous_config_path, config_path; force=true)
            return
        end
    end

    write_ext(config, config_path)

    return
end

main()
