# copied from CUDAdrv/deps/build.jl

using Libdl

function version_hsa(libpath)
    lib = Libdl.dlopen(libpath)
    sym = Libdl.dlsym(lib, "hsa_system_get_info")
    major_ref = Ref{Cushort}(typemax(Cushort))
    minor_ref = Ref{Cushort}(typemax(Cushort))
    status = ccall(sym, Cint, (Cint, Ptr{Cushort}), 0, major_ref)
    @assert status == 0 "HSA error: $status"
    status = ccall(sym, Cint, (Cint, Ptr{Cushort}), 1, minor_ref)
    @assert status == 0 "HSA error: $status"
    return VersionNumber(major_ref[], minor_ref[])
end

function init_hsa(libpath)
    lib = Libdl.dlopen(libpath)
    sym = Libdl.dlsym(lib, "hsa_init")
    ccall(sym, Cint, ())
end

function shutdown_hsa(libpath)
    lib = Libdl.dlopen(libpath)
    sym = Libdl.dlsym(lib, "hsa_shut_down")
    ccall(sym, Cint, ())
end

## auxiliary routines

status = 0
function build_warning(reason)
    println("$reason.")
    global status
    status = 1
    # NOTE: it's annoying that we have to `exit(1)`, but otherwise messages are hidden
end

function build_error(reason)
    println(reason)
    exit(1)
end

## library finding

function find_roc_paths()
    paths = split(get(ENV, "LD_LIBRARY_PATH", ""), ":")
    paths = filter(path->path != "", paths)
    paths = map(Base.Filesystem.abspath, paths)
    push!(paths, "/opt/rocm/hsa/lib") # shim for Ubuntu rocm packages...
    paths = filter(isdir, paths)
    @show paths
    return paths
end

function find_hsa_library(lib, dirs)
    path = Libdl.find_library(lib)
    if path != ""
        return Libdl.dlpath(path)
    end
    for dir in dirs
        files = readdir(dir)
        for file in files
            @info "$file: $(startswith(basename(file), lib * ".so"))"
            if startswith(basename(file), lib * ".so")
                return joinpath(dir, file)
            end
        end
    end
end

function find_ld_lld()
    paths = split(get(ENV, "PATH", ""), ":")
    paths = filter(path->path != "", paths)
    paths = map(Base.Filesystem.abspath, paths)
    ispath("/opt/rocm/llvm/bin/ld.lld") &&
        push!(paths, "/opt/rocm/llvm/bin/")
    ispath("/opt/rocm/hcc/bin/ld.lld") &&
        push!(paths, "/opt/rocm/hcc/bin/")
    ispath("/opt/rocm/opencl/bin/x86_64/ld.lld") &&
        push!(paths, "/opt/rocm/opencl/bin/x86_64/")
    for path in paths
        exp_ld_path = joinpath(path, "ld.lld")
        if ispath(exp_ld_path)
            try
                tmpfile = mktemp()
                run(pipeline(`$exp_ld_path -v`; stdout=tmpfile[1]))
                vstr = read(tmpfile[1], String)
                rm(tmpfile[1])
                vstr_splits = split(vstr, ' ')
                if VersionNumber(vstr_splits[2]) >= v"6.0.0"
                    @info "Found useable ld.lld at $exp_ld_path"
                    return exp_ld_path
                end
            catch
                @warn "Failed running ld.lld in $exp_ld_path"
            end
        end
    end
    return ""
end

function find_roc_library(name::String)
    lib = Libdl.find_library(Symbol(name))
    lib == "" && return nothing
    return Libdl.dlpath(lib)
end

## main

const config_path = joinpath(@__DIR__, "ext.jl")
const previous_config_path = config_path * ".bak"

function write_ext(config, path)
    open(path, "w") do io
        println(io, "# autogenerated file, do not edit")
        for (key,val) in config
            println(io, "const $key = $(repr(val))")
        end
    end
end


function main()
    ispath(config_path) && mv(config_path, previous_config_path; force=true)
    config = Dict{Symbol,Any}(:hsa_configured => false, :ext_libs_configured => false)
    write_ext(config, config_path)


    ## discover stuff

    # check that we're running Linux
    if !Sys.islinux()
        build_error("Not running Linux, which is the only platform currently supported by the ROCm Runtime.")
    end

    roc_dirs = find_roc_paths()

    config[:libhsaruntime_path] = find_hsa_library("libhsa-runtime64", roc_dirs)
    if config[:libhsaruntime_path] == nothing
        build_error("Could not find HSA runtime library.")
    end

    # initializing the library isn't necessary, but flushes out errors that otherwise would
    # happen during `version` or, worse, at package load time.
    status = init_hsa(config[:libhsaruntime_path])
    if status != 0
        build_error("Initializing HSA runtime failed with code $status.")
    end

    config[:libhsaruntime_version] = version_hsa(config[:libhsaruntime_path])

    # also shutdown just in case
    status = shutdown_hsa(config[:libhsaruntime_path])
    if status != 0
        build_error("Shutdown of HSA runtime failed with code $status.")
    end

    # find the ld.lld program for linking kernels
    ld_path = find_ld_lld()
    if ld_path == ""
        build_error("Couldn't find ld.lld, please install it with your package manager")
    end
    config[:ld_lld_path] = ld_path

    config[:hsa_configured] = true

    for name in ("rocblas", "rocsparse", "rocalution", "rocfft", "rocrand", "MIOpen")
        lib = Symbol("lib$(lowercase(name))")
        config[lib] = find_roc_library("lib$name")
        if config[lib] == nothing
            build_warning("Could not find library '$name'")
        end
    end

    lib_hip = Symbol("libhip")
    _paths = String[]
    config[lib_hip] = Libdl.find_library(["libhip_hcc","libamdhip64"], _paths)
    config[lib_hip] == nothing && build_warning("Could not find library HIP")

    ## (re)generate ext.jl

    function globals(mod)
        all_names = names(mod, all=true)
        filter(name-> !any(name .== [nameof(mod), Symbol("#eval"), :eval]), all_names)
    end

    if isfile(previous_config_path)
        @eval module Previous; include($previous_config_path); end
        previous_config = Dict{Symbol,Any}(name => getfield(Previous, name)
                                           for name in globals(Previous))

        if config == previous_config
            mv(previous_config_path, config_path; force=true)
            return
        end
    end

    config[:hsa_configured] = true
    config[:ext_libs_configured] = true
    write_ext(config, config_path)

    if status != 0
        # we got here, so the status is non-fatal
        build_error("""

            AMDGPU.jl has been built successfully, but there were warnings.
            Some functionality may be unavailable.""")
    end
end

# Load HSA and friends, and ROCm external libraries
main()

## Load ROCm Device-Libs

using BinaryProvider # requires BinaryProvider 0.3.0 or later

# Parse some basic command-line arguments
const verbose = "--verbose" in ARGS
const prefix = Prefix(get([a for a in ARGS if a != "--verbose"], 1, joinpath(@__DIR__, "usr")))
products = [
    FileProduct(prefix, "lib/ockl.amdgcn.bc", :rocmdevlibdir),
]

# Download binaries from hosted location
bin_prefix = "https://github.com/jpsamaroo/ROCmDeviceLibsDownloader/releases/download/v2.2.0"

# Listing of files generated by BinaryBuilder:
download_info = Dict(
    Linux(:x86_64, libc=:glibc) => ("$bin_prefix/ROCmDeviceLibsDownloader.v2.2.0.x86_64-linux-gnu.tar.gz", "4bd7c9aaa56f7e72d8707939b28106162df75786ab7a30c35622220aa3a4b7db"),
    Linux(:x86_64, libc=:musl) => ("$bin_prefix/ROCmDeviceLibsDownloader.v2.2.0.x86_64-linux-musl.tar.gz", "dafd049ddeb76491f85bbe7897b4e004326bb8af76e639e925748cad05391a20"),
)

# Install unsatisfied or updated dependencies:
unsatisfied = any(!satisfied(p; verbose=verbose) for p in products)
dl_info = choose_download(download_info, platform_key_abi())
if dl_info === nothing && unsatisfied
    # If we don't have a compatible .tar.gz to download, complain.
    # Alternatively, you could attempt to install from a separate provider,
    # build from source or something even more ambitious here.
    error("Your platform (\"$(Sys.MACHINE)\", parsed as \"$(triplet(platform_key_abi()))\") is not supported by this package!")
end

# If we have a download, and we are unsatisfied (or the version we're
# trying to install is not itself installed) then load it up!
if unsatisfied || !isinstalled(dl_info...; prefix=prefix)
    # Download and install binaries
    install(dl_info...; prefix=prefix, force=true, verbose=verbose)
end

# Write out a deps.jl file that will contain mappings for our products
write_deps_file(joinpath(@__DIR__, "deps.jl"), products, verbose=verbose)
