<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Queues and Signals · AMDGPU.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="AMDGPU.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">AMDGPU.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../quickstart/">Quick Start</a></li><li><a class="tocitem" href="../devices/">Devices/Agents</a></li><li class="is-active"><a class="tocitem" href>Queues and Signals</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Signals"><span>Signals</span></a></li></ul></li><li><a class="tocitem" href="../kernel_deps/">Kernel Dependencies</a></li><li><a class="tocitem" href="../kernel_launch/">Kernel Launch</a></li><li><a class="tocitem" href="../globals/">Global Variables</a></li><li><a class="tocitem" href="../exceptions/">Exceptions</a></li><li><a class="tocitem" href="../printing/">Printing</a></li><li><a class="tocitem" href="../memory/">Memory</a></li><li><span class="tocitem">Intrinsics</span><ul><li><a class="tocitem" href="../execution_control/">Execution Control</a></li><li><a class="tocitem" href="../wavefront_ops/">Wavefront Operations</a></li></ul></li><li><a class="tocitem" href="../logging/">Logging</a></li><li><a class="tocitem" href="../api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Queues and Signals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Queues and Signals</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGPU/AMDGPU.jl/blob/master/docs/src/queues_signals.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Queues"><a class="docs-heading-anchor" href="#Queues">Queues</a><a id="Queues-1"></a><a class="docs-heading-anchor-permalink" href="#Queues" title="Permalink"></a></h1><p>Similar to CUDA streams, ROCm has the concept of queues, which are buffers used to instruct the GPU hardware which kernels to launch. ROCm queues are synchronous, like CUDA streams.</p><p>Each device has a default queue associated, which is accessible with <a href="#AMDGPU.queue"><code>AMDGPU.queue</code></a>.</p><p>To specify which queue to launch a kernel on:</p><ul><li>Using <a href="#AMDGPU.queue!"><code>AMDGPU.queue!</code></a>, which will execute given function and reset   to the original queue after completion:</li></ul><pre><code class="language-julia hljs">q = AMDGPU.ROCQueue()
x = AMDGPU.queue!(() -&gt; AMDGPU.ones(Float32, 16), q)</code></pre><ul><li>Using <code>queue</code> argument to <a href="../api/#AMDGPU.@roc"><code>@roc</code></a> macro:</li></ul><pre><code class="language-julia hljs">q = AMDGPU.ROCQueue()
@roc queue=q kernel(...)</code></pre><p>Queues also have an inherent priority, which allows control of kernel submission latency and on-device scheduling preference with respect to kernels submitted on other queues. There are three priorities: normal (the default), low, and high priority.</p><p>Priority of the default <code>queue</code> can be set with <a href="#AMDGPU.priority!"><code>AMDGPU.priority!</code></a>. Alternatively, it can be set at queue creation time:</p><pre><code class="language-julia hljs">low_prio_queue = ROCQueue(; priority=:low)
high_prio_queue = ROCQueue(; priority=:high)
normal_prio_queue = ROCQueue(; priority=:normal) # or just omit &quot;priority&quot;</code></pre><p>To get kernels which are currently executing on a given queue, use <a href="#AMDGPU.active_kernels"><code>AMDGPU.active_kernels</code></a>. It will return a <code>Vector{ROCKernelSignal}</code>, which can be inspected to determine how many (and which) kernels are executing.</p><p>If a kernel gets &quot;stuck&quot; and locks up the GPU (noticeable with 100% GPU usage in <code>rocm-smi</code>) you can kill it and all other kernels associated with the queue it is running on with <a href="#AMDGPU.Runtime.kill_queue!"><code>AMDGPU.Runtime.kill_queue!(queue)</code></a>. This can be &quot;safely&quot; done to the default queue (obtained via <a href="#AMDGPU.queue"><code>AMDGPU.queue</code></a>), since default queues are recreated as-needed.</p><article class="docstring"><header><a class="docstring-binding" id="AMDGPU.queue" href="#AMDGPU.queue"><code>AMDGPU.queue</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">queue()::ROCQueue</code></pre><p>Get task-local default queue for the currently active device.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/AMDGPU.jl/blob/f584fffcca7be59758bb9abbdc0b70758b5b36a8/src/highlevel.jl#L135-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMDGPU.queue!" href="#AMDGPU.queue!"><code>AMDGPU.queue!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">queue!(f::Base.Callable, queue::ROCQueue)</code></pre><p>Change default queue, execute given function <code>f</code> and revert back to the original queue.</p><p><strong>Returns</strong></p><p>Return value of the function <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/AMDGPU.jl/blob/f584fffcca7be59758bb9abbdc0b70758b5b36a8/src/highlevel.jl#L150-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMDGPU.priority!" href="#AMDGPU.priority!"><code>AMDGPU.priority!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">priority!(priority::Symbol)</code></pre><p>Change the priority of the default queue. Accepted values are <code>:normal</code> (the default), <code>:low</code> and <code>:high</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/AMDGPU.jl/blob/f584fffcca7be59758bb9abbdc0b70758b5b36a8/src/highlevel.jl#L173-L178">source</a></section><section><div><pre><code class="nohighlight hljs">priority!(f::Base.Callable, priority::Symbol)</code></pre><p>Chnage the priority of default queue, execute <code>f</code> and revert to the original priority. Accepted values are <code>:normal</code> (the default), <code>:low</code> and <code>:high</code>.</p><p><strong>Returns</strong></p><p>Return value of the function <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/AMDGPU.jl/blob/f584fffcca7be59758bb9abbdc0b70758b5b36a8/src/highlevel.jl#L184-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMDGPU.active_kernels" href="#AMDGPU.active_kernels"><code>AMDGPU.active_kernels</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">active_kernels(queue::ROCQueue = queue()) -&gt; Vector{ROCKernelSignal}</code></pre><p>Returns the set of actively-executing kernels on <code>queue</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/AMDGPU.jl/blob/f584fffcca7be59758bb9abbdc0b70758b5b36a8/src/highlevel.jl#L288-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMDGPU.Runtime.ROCQueue" href="#AMDGPU.Runtime.ROCQueue"><code>AMDGPU.Runtime.ROCQueue</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ROCQueue(; priority::Symbol=:normal, pooled::Bool=false)</code></pre><p>Create an HSA queue on the currently active device.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Users are encouraged to use this method, instead of manually providing device since this one correctly handles device changes.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/AMDGPU.jl/blob/f584fffcca7be59758bb9abbdc0b70758b5b36a8/src/runtime/queue.jl#L12-L21">source</a></section><section><div><pre><code class="nohighlight hljs">ROCQueue(device::ROCDevice; priority::Symbol=:normal, pooled::Bool=false)</code></pre><p>Create an HSA queue which will be used to instruct GPU hardware which kernels to launch.</p><p>Each queue, spawns an error monitoring thread that&#39;s responsible for actually waiting on kernels and performing a cleanup after kernel finished its execution.</p><div class="admonition is-info"><header class="admonition-header">Oversubscribed Command Queues in GPUs</header><div class="admonition-body"><p>Be careful, with the number of HSA queues in use. When the number of allocated HSA queues is greater than the number of hardware queues, the GPU wastes significant time rotating between all allocated queues in search of ready tasks.</p></div></div><p><strong>Arguments:</strong></p><ul><li><code>device::ROCDevice</code>: Device on which to create queue.</li><li><code>priority::Symbol</code>: Queue&#39;s priority. Can be <code>:normal</code>, <code>:low</code>, <code>:high</code>.</li><li><code>pooled::Bool</code>: Whether to use pool when creating queues.   When <code>true</code>, queues are drawn from it on creation   and returned to pool instead of destroyed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/AMDGPU.jl/blob/f584fffcca7be59758bb9abbdc0b70758b5b36a8/src/runtime/queue.jl#L149-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMDGPU.Runtime.set_queue_pool_size!" href="#AMDGPU.Runtime.set_queue_pool_size!"><code>AMDGPU.Runtime.set_queue_pool_size!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_queue_pool_size!(nums::NTuple{3, Int})</code></pre><p>Set HSA queue pool max size for each priority. Restart Julia session for the changes to take effect.</p><p><strong>Arguments:</strong></p><ul><li><code>nums::NTuple{3, Int}</code>: Maximum number of queues for <code>:normal</code>,   <code>:low</code> and <code>:high</code> priority.   Providing <code>0</code> for specific priority, disables pool for it.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/AMDGPU.jl/blob/f584fffcca7be59758bb9abbdc0b70758b5b36a8/src/runtime/queue.jl#L79-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMDGPU.Runtime.kill_queue!" href="#AMDGPU.Runtime.kill_queue!"><code>AMDGPU.Runtime.kill_queue!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kill_queue!(queue::ROCQueue)</code></pre><p>Kill <code>queue</code> and propagate queue error to all waiter signals in case if there is one.</p><p>If queue is in the pool, it will be removed from it.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>No need to manually call this function during regular use, it will be called automatically from <a href="#AMDGPU.Runtime.ROCQueue"><code>ROCQueue</code></a> finalizer.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGPU/AMDGPU.jl/blob/f584fffcca7be59758bb9abbdc0b70758b5b36a8/src/runtime/queue.jl#L290-L301">source</a></section></article><h1 id="Signals"><a class="docs-heading-anchor" href="#Signals">Signals</a><a id="Signals-1"></a><a class="docs-heading-anchor-permalink" href="#Signals" title="Permalink"></a></h1><p>Unlike CUDA, ROCm kernels are tracked by an associated signal, which is created and returned by <code>@roc</code>, and is <code>wait</code>ed on to track kernel completion. Signals may also be used for manual synchronization (since they work for CPUs and GPUs equally well). CPU usage is done with the <code>HSA.signal_*</code> functions, and GPU usage is done with the <code>device_signal_*</code> and <code>hostcall_device_signal_*</code> functions. For most signalling needs, consider using a hostcall instead.</p><p>If custom signal handling is desired, signals can be manually constructed and passed to <code>@roc</code>:</p><pre><code class="language-julia hljs"># A kernel which waits on all signals in `sigs`
function multi_wait(sigs)
    for i in 1:length(sigs)
        AMDGPU.Device.hostcall_device_signal_wait(sigs[i], 0)
    end
    nothing
end

# Create a set of signals
sigs = [ROCSignal() for i in 1:10]
# Get the device-safe signal handles
_sigs = ROCArray(map(sig-&gt;sig.signal, sigs))

# Launch multi-waiter ahead of time; this will block on the device
final_sig = @roc multi_wait(_sigs)

# Associate kernels with signals
for sig in sigs
    @roc signal=sig identity(nothing)
end

# Wait on the multi-waiter
wait(final_sig)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../devices/">« Devices/Agents</a><a class="docs-footer-nextpage" href="../kernel_deps/">Kernel Dependencies »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 21 April 2023 22:08">Friday 21 April 2023</span>. Using Julia version 1.9.0-rc2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
