var documenterSearchIndex = {"docs":
[{"location":"wavefront_ops/#Wavefront-Operations","page":"Wavefront Operations","title":"Wavefront Operations","text":"","category":"section"},{"location":"wavefront_ops/","page":"Wavefront Operations","title":"Wavefront Operations","text":"These intrinsics provide efficient operations across wavefronts.","category":"page"},{"location":"wavefront_ops/","page":"Wavefront Operations","title":"Wavefront Operations","text":"AMDGPU.wfred","category":"page"},{"location":"execution_control/#Execution-Control-and-Intrinsics","page":"Execution Control","title":"Execution Control and Intrinsics","text":"","category":"section"},{"location":"execution_control/","page":"Execution Control","title":"Execution Control","text":"GPU execution is similar to CPU execution in some ways, although there are many differences. AMD GPUs have Compute Units (CUs), which can be thought of like CPU cores. Those CUs have (on pre-Navi architectures) 64 \"shader processors\", which are essentially the same as CPU SIMD lanes. The lanes in a CU operate in lockstep just like CPU SIMD lanes, and have execution masks and various kinds of SIMD instructions available. CUs execute wavefronts, which are pieces of work split off from a single kernel launch. A single CU can run one out of many wavefronts (one is chosen by the CU scheduler each cycle), which allows for very efficient parallel and concurrent execution on the device. Each wavefront runs independently of the other wavefronts, only stopping to synchronize with other wavefronts or terminate when specified by the program.","category":"page"},{"location":"execution_control/","page":"Execution Control","title":"Execution Control","text":"We can control wavefront execution through a variety of intrinsics provided by ROCm. For example, the endpgm() intrinsic stops the current wavefront's execution, and is also automatically inserted by the compiler at the end of each kernel (except in certain unique cases).","category":"page"},{"location":"execution_control/","page":"Execution Control","title":"Execution Control","text":"signal_completion(x) signals the \"kernel doorbell\" with the value x, which is the signal checked by the CPU wait call to determine when the kernel has completed. This doorbell is set to 0 automatically by GPU hardware once the kernel is complete.","category":"page"},{"location":"execution_control/","page":"Execution Control","title":"Execution Control","text":"sendmsg(x,y=0) and sendmsghalt(x,y=0) can be used to signal special conditions to the scheduler/hardware, such as making requests to stop wavefront generation, or halt all running wavefronts. Check the ISA manual for details!","category":"page"},{"location":"devices/#Devices","page":"Devices","title":"Devices","text":"","category":"section"},{"location":"devices/","page":"Devices","title":"Devices","text":"In AMDGPU, all GPU devices are auto-detected by the runtime, if they're supported.","category":"page"},{"location":"devices/","page":"Devices","title":"Devices","text":"AMDGPU maintains a global default device. The default device is relevant for all kernel and GPUArray operations. If one is not specified via @roc or an equivalent interface, then the default device is used for those operations, which affects compilation and kernel launch.","category":"page"},{"location":"devices/","page":"Devices","title":"Devices","text":"note: Task-Local Storage\nAMDGPU.jl relies on Task-Local Storage, this means that default devices are default only within a given task. Other tasks migh have different default devices if user switched them.","category":"page"},{"location":"devices/","page":"Devices","title":"Devices","text":"The device bound to a current Julia task is accessible via AMDGPU.device(). The list of available devices can be queried with AMDGPU.devices.","category":"page"},{"location":"devices/","page":"Devices","title":"Devices","text":"If you have a HIPDevice object, you can also switch the device with AMDGPU.device!. This will switch it only within the task it is called from.","category":"page"},{"location":"devices/","page":"Devices","title":"Devices","text":"xd1 = AMDGPU.ones(Float32, 16) # On `AMDGPU.device()` device.\n\nAMDGPU.device!(AMDGPU.devices()[2]) # Switch to second device.\nxd2 = AMDPGU.ones(Float32, 16) # On second device.","category":"page"},{"location":"devices/","page":"Devices","title":"Devices","text":"To select a default device for newly created tasks, use AMDGPU.default_device!.","category":"page"},{"location":"devices/","page":"Devices","title":"Devices","text":"AMDGPU.default_device!(AMDGPU.devices()[3]) # New tasks will use 3rd device by default.\nThreads.@spawn begin\n    x = AMDGPU.ones(Float32, 16) # On third device.\n    return\nend","category":"page"},{"location":"devices/","page":"Devices","title":"Devices","text":"Additionally, devices have an associated numeric ID. The default device ID can be queried with AMDGPU.default_device_id, which returns an Int. This value is bounded between 1 and length(AMDGPU.devices()), and device 1 is the default device when AMDGPU is first loaded. The ID of the device associated with the current task can be queried with AMDGPU.device_id and changed with AMDGPU.device_id!.","category":"page"},{"location":"devices/","page":"Devices","title":"Devices","text":"AMDGPU.devices\nAMDGPU.device\nAMDGPU.device!\nAMDGPU.default_device\nAMDGPU.default_device!\nAMDGPU.device_id\nAMDGPU.device_id!\nAMDGPU.default_device_id\nAMDGPU.default_device_id!","category":"page"},{"location":"devices/#AMDGPU.devices","page":"Devices","title":"AMDGPU.devices","text":"devices()\n\nGet list of all devices.\n\n\n\n\n\n","category":"function"},{"location":"devices/#AMDGPU.device","page":"Devices","title":"AMDGPU.device","text":"device()::HIPDevice\n\nGet currently active device. This device is used when launching kernels via @roc.\n\n\n\n\n\ndevice(A::ROCArray) -> HIPDevice\n\nReturn the device associated with the array A.\n\n\n\n\n\n","category":"function"},{"location":"devices/#AMDGPU.device!","page":"Devices","title":"AMDGPU.device!","text":"device!(device::HIPDevice)\n\nSwitch current device being used. This switches only for a task inside which it is called.\n\nnote: Note\nTo select default device that will be used when creating new tasks, refer to default_device! for that.\n\n\n\n\n\n","category":"function"},{"location":"devices/#AMDGPU.default_device","page":"Devices","title":"AMDGPU.default_device","text":"default_device()::HIPDevice\n\nDefault device which will be used by default in tasks. Meaning when a task is created, it selects this device as default.\n\nAll subsequent uses rely on device() for device selection.\n\n\n\n\n\n","category":"function"},{"location":"devices/#AMDGPU.default_device!","page":"Devices","title":"AMDGPU.default_device!","text":"default_device!(device::HIPDevice)\n\nSet default device that will be used when creating new tasks.\n\nnote: Note\nThis does not change current device being used. Refer to device! for that.\n\n\n\n\n\n","category":"function"},{"location":"devices/#AMDGPU.device_id","page":"Devices","title":"AMDGPU.device_id","text":"device_id(device::HIPDevice) -> Int\n\nReturns the numerical device ID for device. See default_device_id for details on the numbering semantics.\n\n\n\n\n\n","category":"function"},{"location":"devices/#AMDGPU.device_id!","page":"Devices","title":"AMDGPU.device_id!","text":"device_id!(idx::Integer, kind::Symbol=:gpu)\n\nSets the current device to AMDGPU.devices(kind)[idx]. See device_id for details on the numbering semantics.\n\n\n\n\n\n","category":"function"},{"location":"devices/#AMDGPU.default_device_id","page":"Devices","title":"AMDGPU.default_device_id","text":"default_device_id() -> Int\n\nReturns the numeric ID of the current default device, which is in the range of 1:length(AMDGPU.devices()). This number should be stable for all processes on the same node, The default_device_id! function accepts the same numeric ID that is produced by this function.\n\n\n\n\n\n","category":"function"},{"location":"devices/#AMDGPU.default_device_id!","page":"Devices","title":"AMDGPU.default_device_id!","text":"default_device_id!(idx::Integer, kind::Symbol=:gpu)\n\nSets the default device to AMDGPU.devices(kind)[idx]. See default_device_id for details on the numbering semantics.\n\n\n\n\n\n","category":"function"},{"location":"hostcall/#Hostcall","page":"Host-Call","title":"Hostcall","text":"","category":"section"},{"location":"hostcall/","page":"Host-Call","title":"Host-Call","text":"Hostcalls provide a means for GPU-CPU communications within running kernels.","category":"page"},{"location":"hostcall/","page":"Host-Call","title":"Host-Call","text":"AMDGPU.jl provides its own implementation of hostcalls, relying on HSA signals. Currently, hostcalls are used for device-side allocations, printing and exception reporting.","category":"page"},{"location":"hostcall/","page":"Host-Call","title":"Host-Call","text":"Some of the hostcalls (global hostcalls), are launched automatically, if their usage is detected during compilation (e.g. device-side allocations, exception reporting).","category":"page"},{"location":"hostcall/","page":"Host-Call","title":"Host-Call","text":"Hostcalls require careful usage, since they each spawn their own Tasks. There should be no blocking operations during this time.","category":"page"},{"location":"hostcall/","page":"Host-Call","title":"Host-Call","text":"For example, using non-blocking synchronization instead of blocking with AMDGPU.synchronize(; blocking=false).","category":"page"},{"location":"hostcall/","page":"Host-Call","title":"Host-Call","text":"Non-blocking synchronization is also responsible for stopping global hostcalls, otherwise the performance might degarde because of constant pooling of HSA signals in a loop.","category":"page"},{"location":"hostcall/#Example","page":"Host-Call","title":"Example","text":"","category":"section"},{"location":"hostcall/","page":"Host-Call","title":"Host-Call","text":"hc = Device.HostCallHolder(Float32, Tuple{Float32}) do x\n    return x + 42f0\nend\n\nfunction kernel!(y, hc)\n    y[1] = Device.hostcall!(hc, y[1])\n    return\nend\n\ny = ROCArray(Float32[0f0])\n@roc kernel!(y, hc)\nAMDGPU.synchronize(; blocking=false) # Non-blocking sync to prevent hanging.\n\n@assert Array(y)[1] ≈ 42f0","category":"page"},{"location":"hostcall/","page":"Host-Call","title":"Host-Call","text":"In this example, HostCallHolder is used to create and launch HostCall. HostCallHolder contains the HostCall structure itself that is passed to kernel, a task that is spawned on creation and some additional info for controlling the lifetime of the task.","category":"page"},{"location":"hostcall/","page":"Host-Call","title":"Host-Call","text":"First argument is a function we want to execute when we call the hostcall. In this case we add 42f0 to input argument x and return the result.","category":"page"},{"location":"hostcall/","page":"Host-Call","title":"Host-Call","text":"Second and third arguments are the return type Float32 and the tuple of types of input arguments Tuple{Float32}.","category":"page"},{"location":"hostcall/","page":"Host-Call","title":"Host-Call","text":"hostcall! is used to execute the function on the host, wait on the result, and obtain the return values. At the moment, it is performed once per workgroup.","category":"page"},{"location":"hostcall/#Continuous-Host-Call","page":"Host-Call","title":"Continuous Host-Call","text":"","category":"section"},{"location":"hostcall/","page":"Host-Call","title":"Host-Call","text":"By default, hostcalls can be used only once. After executing the function on the host, the task finishes and exits.","category":"page"},{"location":"hostcall/","page":"Host-Call","title":"Host-Call","text":"However, if you need your hostcall to live indefinitely, pass continuous=true keyword argument to HostCallHolder(...; continuous=true).","category":"page"},{"location":"hostcall/","page":"Host-Call","title":"Host-Call","text":"To then stop the hostcall, call Device.non_continuous!(hc) or Device.finish!(hc) on the HostCallHolder.","category":"page"},{"location":"hostcall/","page":"Host-Call","title":"Host-Call","text":"The difference between them is that non_continuous! will allow calling hostcall one more time before exiting, while finish! will exit immediately.","category":"page"},{"location":"hostcall/","page":"Host-Call","title":"Host-Call","text":"finish! can be used on any HostCallHolder to force-exit the running hostcall task.","category":"page"},{"location":"logging/#Runtime-and-Compiler-Logging","page":"Logging","title":"Runtime and Compiler Logging","text":"","category":"section"},{"location":"logging/","page":"Logging","title":"Logging","text":"AMDGPU.jl has a built-in logging system integrated into various runtime and compiler operations, which is provided by TimespanLogging.jl. Operations such as compilation and linking, signal and buffer allocation/freeing, kernel launch, etc. are instrumented with logging statements, allowing the user to record the start and end of operations.","category":"page"},{"location":"logging/","page":"Logging","title":"Logging","text":"While disabled by default, logging can be enabled by first running AMDGPU.Runtime.enable_logging!() to globally enable logging, after which Julia must be restarted for the changes to take effect.","category":"page"},{"location":"logging/","page":"Logging","title":"Logging","text":"Once logging is globally enabled, AMDGPU.Runtime.start_logging() causes new log events to be saved, while AMDGPU.Runtime.stop_logging() causes new log events to be discarded. Log events can be collected with AMDGPU.Runtime.fetch_logs!(). A more convenient option is AMDGPU.Runtime.log_and_fetch!(f), which can be used to easily log operations within a region of code:","category":"page"},{"location":"logging/","page":"Logging","title":"Logging","text":"logs = AMDGPU.Runtime.log_and_fetch!() do\n    A = AMDGPU.ones(3, 4)\n    B = copy(A)\n    fill!(B, 1f0)\n    C = Array(B)\nend\n@show logs[1]","category":"page"},{"location":"api/#AMDGPU-API-Reference","page":"API Reference","title":"AMDGPU API Reference","text":"","category":"section"},{"location":"api/#Kernel-launching","page":"API Reference","title":"Kernel launching","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"@roc\nAMDGPU.AbstractKernel\nAMDGPU.HostKernel\nAMDGPU.rocfunction","category":"page"},{"location":"api/#Device-code-API","page":"API Reference","title":"Device code API","text":"","category":"section"},{"location":"api/#Thread-indexing","page":"API Reference","title":"Thread indexing","text":"","category":"section"},{"location":"api/#HSA-nomenclature","page":"API Reference","title":"HSA nomenclature","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"AMDGPU.workitemIdx\nAMDGPU.workgroupIdx\nAMDGPU.workgroupDim\nAMDGPU.gridItemDim\nAMDGPU.gridGroupDim","category":"page"},{"location":"api/#AMDGPU.Device.workitemIdx","page":"API Reference","title":"AMDGPU.Device.workitemIdx","text":"workitemIdx()::ROCDim3\n\nReturns the work item index within the work group. See also: threadIdx\n\n\n\n\n\n","category":"function"},{"location":"api/#AMDGPU.Device.workgroupIdx","page":"API Reference","title":"AMDGPU.Device.workgroupIdx","text":"workgroupIdx()::ROCDim3\n\nReturns the work group index. See also: blockIdx\n\n\n\n\n\n","category":"function"},{"location":"api/#AMDGPU.Device.workgroupDim","page":"API Reference","title":"AMDGPU.Device.workgroupDim","text":"workgroupDim()::ROCDim3\n\nReturns the size of each workgroup in workitems. See also: blockDim\n\n\n\n\n\n","category":"function"},{"location":"api/#AMDGPU.Device.gridItemDim","page":"API Reference","title":"AMDGPU.Device.gridItemDim","text":"gridItemDim()::ROCDim3\n\nReturns the size of the grid in workitems. This behaviour is different from CUDA where gridDim gives the size of the grid in blocks.\n\n\n\n\n\n","category":"function"},{"location":"api/#AMDGPU.Device.gridGroupDim","page":"API Reference","title":"AMDGPU.Device.gridGroupDim","text":"gridGroupDim()::ROCDim3\n\nReturns the size of the grid in workgroups. This is equivalent to CUDA's gridDim.\n\n\n\n\n\n","category":"function"},{"location":"api/#CUDA-nomenclature","page":"API Reference","title":"CUDA nomenclature","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Use these functions for compatibility with CUDA.jl.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"AMDGPU.Device.threadIdx\nAMDGPU.Device.blockIdx\nAMDGPU.Device.blockDim","category":"page"},{"location":"api/#AMDGPU.Device.threadIdx","page":"API Reference","title":"AMDGPU.Device.threadIdx","text":"threadIdx()::ROCDim3\n\nReturns the thread index within the block. See also: workitemIdx\n\n\n\n\n\n","category":"function"},{"location":"api/#AMDGPU.Device.blockIdx","page":"API Reference","title":"AMDGPU.Device.blockIdx","text":"blockIdx()::ROCDim3\n\nReturns the block index within the grid. See also: workgroupIdx\n\n\n\n\n\n","category":"function"},{"location":"api/#AMDGPU.Device.blockDim","page":"API Reference","title":"AMDGPU.Device.blockDim","text":"blockDim()::ROCDim3\n\nReturns the dimensions of the block. See also: workgroupDim\n\n\n\n\n\n","category":"function"},{"location":"api/#Synchronization","page":"API Reference","title":"Synchronization","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"AMDGPU.sync_workgroup","category":"page"},{"location":"api/#AMDGPU.Device.sync_workgroup","page":"API Reference","title":"AMDGPU.Device.sync_workgroup","text":"sync_workgroup()\n\nWaits until all wavefronts in a workgroup have reached this call.\n\n\n\n\n\n","category":"function"},{"location":"api/#Global-Variables","page":"API Reference","title":"Global Variables","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"AMDGPU.Device.get_global_pointer","category":"page"},{"location":"kernel_launch/#Kernel-Launch","page":"Kernel Launch","title":"Kernel Launch","text":"","category":"section"},{"location":"kernel_launch/#Launch-Configuration","page":"Kernel Launch","title":"Launch Configuration","text":"","category":"section"},{"location":"kernel_launch/","page":"Kernel Launch","title":"Kernel Launch","text":"While an almost arbitrarily large number of workitems can be executed per kernel launch, the hardware can only support executing a limited number of wavefronts at one time.","category":"page"},{"location":"kernel_launch/","page":"Kernel Launch","title":"Kernel Launch","text":"To alleviate this, the compiler calculates the \"occupancy\" of each compiled kernel (which is the number of wavefronts that can be simultaneously executing on the GPU), and passes this information to the hardware; the hardware then launches a limited number of wavefronts at once, based on the kernel's \"occupancy\" values.","category":"page"},{"location":"kernel_launch/","page":"Kernel Launch","title":"Kernel Launch","text":"The rest of the wavefronts are not launched until hardware resources become available, which means that a kernel with better occupancy will see more of its wavefronts executing simultaneously (which often leads to better performance). Suffice to say, it's important to know the occupancy of kernels if you want the best performance.","category":"page"},{"location":"kernel_launch/","page":"Kernel Launch","title":"Kernel Launch","text":"Like CUDA.jl, AMDGPU.jl has the ability to calculate kernel occupancy, with the launch_configuration function:","category":"page"},{"location":"kernel_launch/","page":"Kernel Launch","title":"Kernel Launch","text":"kernel = @roc launch=false mykernel(args...)\noccupancy = AMDGPU.launch_configuration(kernel)\n@show occupancy.gridsize\n@show occupancy.groupsize","category":"page"},{"location":"kernel_launch/","page":"Kernel Launch","title":"Kernel Launch","text":"Specifically, launch_configuration calculates the occupancy of mykernel(args...), and then calculates an optimal groupsize based on the occupancy. This value can then be used to select the groupsize for the kernel:","category":"page"},{"location":"kernel_launch/","page":"Kernel Launch","title":"Kernel Launch","text":"@roc groupsize=occupancy.groupsize mykernel(args...)","category":"page"},{"location":"quickstart/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quickstart/#Installation","page":"Quick Start","title":"Installation","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"See JLL usage for info about ROCm stack installation. Simply add the AMDGPU.jl package to your Julia environment:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"using Pkg\nPkg.add(\"AMDGPU\")","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"You can then load the AMDGPU package and run the unit tests:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"using AMDGPU\nusing Pkg\nPkg.test(\"AMDGPU\")","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"warning: Warning\nIf you get an error message along the lines of GLIB_CXX_... not found, it's possible that the C++ runtime used to build the ROCm stack and the one used by Julia are different. If you built the ROCm stack yourself this is very likely the case since Julia normally ships with its own C++ runtime. For more information, check out this GitHub issue.A quick fix is to use the LD_PRELOAD environment variable to make Julia use the system C++ runtime library, for example:LD_PRELOAD=/usr/lib/libstdc++.so juliaAlternatively, you can build Julia from source as described here.You can quickly debug this issue by starting Julia and trying to load a ROCm library:using Libdl\nLibdl.dlopen(\"/opt/rocm/hsa/lib/libhsa-runtime64.so.1\")","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"warning: Warning\nIf during the build process you get an error message along the lines of hipErrorNoBinaryForGpu: Coudn't find binary for current devices! and you already have ROCm installed locally then you should set the environment variable JULIA_AMDGPU_DISABLE_ARTIFACTS=1 and reload AMDGPU.jl.","category":"page"},{"location":"quickstart/#Running-a-simple-kernel","page":"Quick Start","title":"Running a simple kernel","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"As a simple test, we will try to add two random vectors and make sure that the results from the CPU and the GPU are indeed the same.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"We can start by first performing this simple calculation on the CPU:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"N = 1024\na = rand(Float64, N)\nb = rand(Float64, N)\nc_cpu = a + b","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"To do the same computation on the GPU, we first need to copy the two input arrays a and b to the device. Toward that end, we will use the ROCArray type to represent our GPU arrays. We can create the two arrays by passing the host data to the constructor as follows:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"using AMDGPU\na_d = ROCArray(a)\nb_d = ROCArray(b)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"We need to create one additional array c_d to store the results:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"c_d = similar(a_d)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"In this example, the postfix _d distinguishes a device memory object from its host memory counterpart. This convention is completely arbitrary and you may name your device-side variables whatever you like; they are regular Julia variables.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Next, we will define the GPU kernel that does the actual computation:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"function vadd!(c, a, b)\n    i = workitemIdx().x + (workgroupIdx().x - 1) * workgroupDim().x\n    c[i] = a[i] + b[i]\n    return\nend","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"The index of a single workitem can be uniquely identified by its grid index (computed linearly as (workgroupDim().x * (workgroupIdx().x - 1)) + workitemIdx().x when only a single dimension is used).","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"The grid is the domain over which the entire kernel executes over. The grid will be split into multiple workgroups by hardware automatically, and the kernel does not complete until all workgroups complete.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Like OpenCL, AMDGPU has the concept of \"workitems\", \"workgroups\", and the \"grid\". A workitem is a single thread of execution, capable of performing arithmentic operations. Workitems are grouped into \"wavefronts\" (\"warps\" in CUDA) which share the same compute unit, and execute the same instructions simulatenously. The workgroup is a logical unit of compute supported by hardware which comprises multiple wavefronts, which shares resources (specifically local memory) and can be efficiently synchronized. A workgroup may be executed by one or multiple hardware compute units, making it often the only dimension of importance for smaller kernel launches.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Notice how we explicitly specify that this function does not return a value by adding the return statement. This is necessary for all GPU kernels and we can enforce it by adding a return, return nothing, or even nothing at the end of the kernel. If this statement is omitted, Julia will attempt to return the value of the last evaluated expression, in this case a Float64, which will cause a compilation failure as kernels cannot return values.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"The easiest way to launch a GPU kernel is with the @roc macro, specifying groupsize and gridsize to cover full array, and calling it like a regular function:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"groupsize = 128\ngridsize = cld(length(c_d), groupsize)\n@roc gridsize=gridsize groupsize=groupsize vadd!(c_d, a_d, b_d)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Keep in mind that kernel launches are asynchronous, meaning that you need to do some kind of synchronization before you use the result. For instance, you can call AMDGPU.synchronize():","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"@roc groupsize=N vadd!(c_d, a_d, b_d)\nAMDGPU.synchronize()","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Finally, we can make sure that the results match, by first copying the data to the host and then comparing it with the CPU results:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"c = Array(c_d)\n\nusing Test\n@test isapprox(c, c_cpu)","category":"page"},{"location":"quickstart/#Naming-conventions","page":"Quick Start","title":"Naming conventions","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Throughout this example we use terms like \"work group\" and \"work item\". These terms are used by the Khronos consortium and their APIs including OpenCL and Vulkan, as well as the HSA foundation.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"NVIDIA, on the other hand, uses some different terms in their CUDA API, which might be confusing to some users porting their kernels from CUDA to AMDGPU.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"As a quick summary, here is a mapping of the most common terms:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"AMDGPU CUDA\nworkitemIdx threadIdx\nworkgroupIdx blockIdx\nworkgroupDim blockDim\ngridItemDim No equivalent\ngridGroupDim gridDim\ngroupsize threads\ngridsize blocks * threads\nqueue stream","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"For compatibilty reasons, the symbols in the CUDA column (except for gridItemDim) are also supported by AMDGPU.","category":"page"},{"location":"memory/#Memory-Allocation-and-Intrinsics","page":"Memory","title":"Memory Allocation and Intrinsics","text":"","category":"section"},{"location":"memory/#Memory-Varieties","page":"Memory","title":"Memory Varieties","text":"","category":"section"},{"location":"memory/","page":"Memory","title":"Memory","text":"GPUs contain various kinds of memory, just like CPUs:","category":"page"},{"location":"memory/","page":"Memory","title":"Memory","text":"Global:   Globally accessible by all CUs on a GPU, and possibly accessible   from outside of the GPU (by the CPU host, by other GPUs, by PCIe devices,   etc.). Slowest form of memory.\nConstant:   Same as global memory, but signals to the hardware that it can use   special instructions to access and cache this memory.   Can be changed between kernel invocations.\nRegion:   Also known as Global Data Store (GDS), all wavefronts on a CU   can access the same memory region from the same address.   Faster than Global/Constant.   Automatically allocated by the compiler/runtime, not user accessible.\nLocal:   Also known as Local Data Store (LDS), all wavefronts in the same workgroup   can access the same memory region from the same address.   Faster than GDS.\nPrivate:   Uses the hardware scratch space, and is private to each SIMD lane   in a wavefront.   Fastest form of traditional memory.","category":"page"},{"location":"memory/#Local-Memory","page":"Memory","title":"Local Memory","text":"","category":"section"},{"location":"memory/","page":"Memory","title":"Memory","text":"Local memory may be allocated within a kernel by calling either:","category":"page"},{"location":"memory/","page":"Memory","title":"Memory","text":"@ROCStaticLocalArray(T, dims) - if dims is passed as a constant value,   known at compile-time.   E.g. @ROCStaticLocalArray(Float32, 8).\n@ROCDynamicLocalArray(T, dims) - otherwise.   E.g. @ROCStaticLocalArray(Float32, length(X)).","category":"page"},{"location":"memory/","page":"Memory","title":"Memory","text":"Local memory is zero-initialized by default. If this is unnecessary and undesired for performance reasons, disable this, passing false as a last argument: @ROCStaticLocalArray(Float32, 8, false) or @ROCStaticLocalArray(Float32, length(X), false)","category":"page"},{"location":"memory/","page":"Memory","title":"Memory","text":"Local memory does not need to be freed, as it is automatically freed by the hardware.","category":"page"},{"location":"memory/","page":"Memory","title":"Memory","text":"If @ROCDynamicLocalArray is used, then local memory is dynamically allocated at kernel execution time. The shmem option to @roc must be set appropriately to ensure that enough local memory is allocated by the hardware.","category":"page"},{"location":"memory/","page":"Memory","title":"Memory","text":"It is allocated in addition to the local memory that is statically allocated by the kernel.","category":"page"},{"location":"memory/","page":"Memory","title":"Memory","text":"function kernel(C, A)\n    # Allocate local memory dynamically\n    Ctmp = @ROCDynamicLocalArray(Float64, length(C))\n    # Or, allocate local memory statically if the size is known ahead-of-time\n    Ctmp = @ROCStaticLocalArray(Float64, 8) # if we want 8 elements\n\n    idx = AMDGPU.workitemIdx().x\n    Ctmp[idx] = A[idx] + C[1]\n    AMDGPU.Device.sync_workgroup()\n\n    C[idx] = Ctmp[idx]\n    return\nend\n\n...\n# Note: The `shmem` option isn't necessary if `@ROCStaticLocalArray` is used\nshmem = sizeof(Float64) * length(RC)\n@roc groupsize=8 shmem=shmem kernel(RC, RA)","category":"page"},{"location":"memory/#Device-Side-Allocations","page":"Memory","title":"Device-Side Allocations","text":"","category":"section"},{"location":"memory/","page":"Memory","title":"Memory","text":"Global memory may be allocated/freed dynamically from kernels by calling AMDGPU.Device.malloc(::Csize_t)::Ptr{Cvoid} and AMDGPU.Device.free(::Ptr{Cvoid}).","category":"page"},{"location":"memory/","page":"Memory","title":"Memory","text":"This memory allocation/deallocation uses hostcalls to operate, and so is relatively slow, but is also very useful. See Hostcall section for more info about them.","category":"page"},{"location":"memory/","page":"Memory","title":"Memory","text":"Memory allocated with AMDGPU.Device.malloc is a host-pinned memory. Calls to malloc and free are performed once per workgroup, so ensure that enough memory has been allocated to feed the lanes that will be accessing it.","category":"page"},{"location":"memory/","page":"Memory","title":"Memory","text":"As an example, here's how an array could be allocated on-device to store temporary results:","category":"page"},{"location":"memory/","page":"Memory","title":"Memory","text":"function kernel(C, A)\n    # Allocate memory dynamically and get a pointer to it.\n    Ctmp_ptr = AMDGPU.Device.malloc(Csize_t(sizeof(Float64) * length(C)))\n    # Turn a pointer into a device-side array.\n    Ctmp = ROCDeviceArray(length(C), reinterpret(Core.LLVMPtr{Float64,1}, Ctmp_ptr))\n\n    # Use it\n    idx = AMDGPU.workitemIdx().x\n    Ctmp[idx] = A[idx] + C[1]\n    AMDGPU.Device.sync_workgroup()\n\n    C[idx] = Ctmp[idx]\n    # Make sure to free it.\n    AMDGPU.Device.free(Ctmp_ptr)\n    return\nend\n\nRA = AMDGPU.rand(4)\nRC = AMDGPU.rand(4)\nRC_elem = Array(RC)[1]\n@roc groupsize=4 kernel(RC, RA)\n@assert Array(RC) ≈ Array(RA) .+ RC_elem","category":"page"},{"location":"memory/#Memory-Modification-Intrinsics","page":"Memory","title":"Memory Modification Intrinsics","text":"","category":"section"},{"location":"memory/","page":"Memory","title":"Memory","text":"Like C, AMDGPU.jl provides the memset! and memcpy! intrinsics, which are useful for setting a memory region to a value, or copying one region to another, respectively. Check test/device/memory.jl for examples of their usage.","category":"page"},{"location":"printing/#Printing","page":"Printing","title":"Printing","text":"","category":"section"},{"location":"printing/","page":"Printing","title":"Printing","text":"Writing GPU kernels can be a difficult endeavor, owing to the fact that the LLVM GPU backends turn serial code into parallel code automatically. Recognizing this, every good GPU programming interface allows the user's GPU kernels to print output to a buffer, which will be passed to the host for display. With the ability to interpolate variables, this functionality serves as the \"printf of GPUs\". Quite literally, the primary tool for this is @rocprintf. Here's a simple example of printing the current workgroup index:","category":"page"},{"location":"printing/","page":"Printing","title":"Printing","text":"kernel(x) = @rocprintf \"Workgroup index: %d\\n\" workgroupIdx().x","category":"page"},{"location":"printing/","page":"Printing","title":"Printing","text":"The above kernel would print out the string \"Workgroup index: 1\\n\" when run with a single workgroup (where \"\\n\" means a newline).","category":"page"},{"location":"printing/","page":"Printing","title":"Printing","text":"Any number of variables may be passed to @rocprintf, as long as those variables have a printf-compatible implementation in Printf.@printf. Calls to @rocprintf are blocking, and will not return control to the kernel until the string has been formatted and sent to the OS runtime for printing (the same as for calls to Printf.@printf).","category":"page"},{"location":"printing/","page":"Printing","title":"Printing","text":"While @rocprintf is printed once per workgroup by default, it's possible to print once per lane, once per wavefront, or once per grid by specifying an execution mode as the first argument:","category":"page"},{"location":"printing/","page":"Printing","title":"Printing","text":"# Once per lane\nkernel(x) = @rocprintf :lane \"My index is: %d\\n\" workitemIdx().x\n\n# Once per wavefront\nkernel(x) = @rocprintf :wave \"My index is: %d\\n\" workitemIdx().x\n\n# Once per workgroup\nkernel(x) = @rocprintf :group \"My index is: %d\\n\" workitemIdx().x\n# OR (:group is the default)\nkernel(x) = @rocprintf \"My index is: %d\\n\" workitemIdx().x\n\n# Once total\nkernel(x) = @rocprintf :grid \"My index is: %d\\n\" workitemIdx().x","category":"page"},{"location":"printing/","page":"Printing","title":"Printing","text":"Executing those kernels with 256 workitems split evenly between 2 workgroups would print out:","category":"page"},{"location":"printing/","page":"Printing","title":"Printing","text":"# :lane\nMy index is 1\nMy index is 2\n...\nMy index is 127\nMy index is 128\nMy index is 1\nMy index is 2\n...\nMy index is 127\nMy index is 128\n\n# :wave\nMy index is 1\nMy index is 65\nMy index is 1\nMy index is 65\n\n# :group\nMy index is 1\nMy index is 1\n\n# :grid\nMy index is 1","category":"page"},{"location":"printing/#Differences-to-@cuprintf","page":"Printing","title":"Differences to @cuprintf","text":"","category":"section"},{"location":"printing/","page":"Printing","title":"Printing","text":"Similar to CUDA's @cuprintf, @rocprintf is a printf-compatible macro which takes a format string and arguments, and commands the host CPU to display it as formatted text. However, in contrast to @cuprintf, we use AMDGPU's hostcall and Julia's Printf stdlib to implement this. This means that anything that Printf can print, so can @rocprintf (assuming such an object can be represented on the GPU). The macro is also handled as a regular hostcall, which means that argument types are checked at compile time (although currently, any errors while printing will be detected on the host, and will terminate the kernel).","category":"page"},{"location":"streams/#Streams","page":"Streams","title":"Streams","text":"","category":"section"},{"location":"streams/","page":"Streams","title":"Streams","text":"Similar to CUDA streams, ROCm has HIP streams, which are buffers used to instruct the GPU hardware which kernels to launch. HIP streams are synchronous, like CUDA streams.","category":"page"},{"location":"streams/","page":"Streams","title":"Streams","text":"Each device has a default stream associated, which is accessible with AMDGPU.stream().","category":"page"},{"location":"streams/","page":"Streams","title":"Streams","text":"There are several ways to specify which stream to launch a kernel on:","category":"page"},{"location":"streams/","page":"Streams","title":"Streams","text":"Using AMDGPU.stream! to change default stream to be used   within the same Julia task.","category":"page"},{"location":"streams/","page":"Streams","title":"Streams","text":"stream = AMDGPU.HIPStream()\nAMDGPU.stream!(stream) # Change default stream to be used for subsequent operations.\nAMDGPU.ones(Float32, 16) # Will be executed on `stream`.","category":"page"},{"location":"streams/","page":"Streams","title":"Streams","text":"Using AMDGPU.stream! to execute given function and reset   to the original stream after completion:","category":"page"},{"location":"streams/","page":"Streams","title":"Streams","text":"stream = AMDGPU.HIPStream()\nx = AMDGPU.stream!(() -> AMDGPU.ones(Float32, 16), stream)","category":"page"},{"location":"streams/","page":"Streams","title":"Streams","text":"Using stream argument to @roc macro:","category":"page"},{"location":"streams/","page":"Streams","title":"Streams","text":"stream = AMDGPU.HIPStream()\n@roc stream=stream kernel(...)","category":"page"},{"location":"streams/","page":"Streams","title":"Streams","text":"Streams also have an inherent priority, which allows control of kernel submission latency and on-device scheduling preference with respect to kernels submitted on other streams. There are three priorities: normal (the default), low, and high priority.","category":"page"},{"location":"streams/","page":"Streams","title":"Streams","text":"Priority of the default stream can be set with AMDGPU.priority!. Alternatively, it can be set at stream creation time:","category":"page"},{"location":"streams/","page":"Streams","title":"Streams","text":"low_prio = HIPStream(:low)\nhigh_prio = HIPStream(:high)\nnormal_prio = HIPStream(:normal) # or just omit \"priority\"","category":"page"},{"location":"streams/","page":"Streams","title":"Streams","text":"AMDGPU.stream\nAMDGPU.stream!\nAMDGPU.priority!\nAMDGPU.HIPStream","category":"page"},{"location":"streams/#AMDGPU.priority!","page":"Streams","title":"AMDGPU.priority!","text":"priority!(priority::Symbol)\n\nChange the priority of the default stream. Accepted values are :normal (the default), :low and :high.\n\n\n\n\n\npriority!(f::Base.Callable, priority::Symbol)\n\nChnage the priority of default stream, execute f and revert to the original priority. Accepted values are :normal (the default), :low and :high.\n\nReturns\n\nReturn value of the function f.\n\n\n\n\n\n","category":"function"},{"location":"streams/#AMDGPU.HIP.HIPStream","page":"Streams","title":"AMDGPU.HIP.HIPStream","text":"HIPStream(priority::Symbol = :normal)\n\nArguments:\n\npriority::Symbol: Priority of the stream: :normal, :high or :low.\n\nCreate HIPStream with given priority. Device is the default device that's currently in use.\n\n\n\n\n\nHIPStream(stream::hipStream_t)\n\nCreate HIPStream from hipStream_t handle. Device is the default device that's currently in use.\n\n\n\n\n\n","category":"type"},{"location":"#Programming-AMD-GPUs-with-Julia","page":"Home","title":"Programming AMD GPUs with Julia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"tip: Tip\nThis documentation assumes that you are familiar with the main concepts of GPU programming and mostly describes the specifics of running Julia code on AMD GPUs. For a much more gentle introduction to GPGPU with Julia consult the well-written CUDA.jl documentation.","category":"page"},{"location":"#The-ROCm-stack","page":"Home","title":"The ROCm stack","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ROCm (short for Radeon Open Compute platforM) is AMD's open-source GPU computing platform, supported by most modern AMD GPUs (detailed hardware support) and some AMD APUs. ROCm works solely on Linux and no plans to support either Windows or macOS have been announced by AMD.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A necessary prerequisite to use this Julia package is to have a working ROCm stack installed. A quick way to verify this is to check the output of rocminfo. For more information, consult the official installation guide. Even though the only platforms officially supported by AMD are certain versions of Ubuntu, CentOS, RHEL, and SLES [1], there are options to install ROCm on other Linux distributions, including:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Arch Linux - See the rocm-arch repository or the slightly older PKGBUILDs in the AUR.\nGentoo - Check Portage for the rocr-runtime package and justxi's rocm repo for unofficial ROCm package ebuilds.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[1]: https://github.com/RadeonOpenCompute/ROCm/wiki#supported-operating-systems","category":"page"},{"location":"#The-Julia-AMDGPU-stack","page":"Home","title":"The Julia AMDGPU stack","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia support for programming AMD GPUs is currently provided by the AMDGPU.jl package. This package contains everything necessary to program for AMD GPUs in Julia, including:","category":"page"},{"location":"","page":"Home","title":"Home","text":"An interface for working with the HSA runtime API, necessary for launching compiled kernels and controlling the GPU.\nAn interface for compiling and running kernels written in Julia through LLVM's AMDGPU backend.\nAn array type implementing the GPUArrays.jl interface, providing high-level array operations.","category":"page"},{"location":"#Required-Software","page":"Home","title":"Required Software","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ROCT (JLL available)\nROCR (JLL available)\nROCm-Device-Libs (JLL available)\nHIP (JLL available)\nRecent Linux kernel with AMDGPU and HSA enabled (Cannot be provided as a JLL)\nld.lld binary provided by system LLVM (No JLL yet)","category":"page"},{"location":"#Optional-Packages","page":"Home","title":"Optional Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"rocBLAS for BLAS support (JLL available)\nrocFFT for FFT support (No JLL yet)\nrocRAND for RNG support (JLL available)\nMIOpen for DNN support (JLL available on Julia 1.9)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Other ROCm packages are currently unused by AMDGPU.","category":"page"},{"location":"#JLL-usage","page":"Home","title":"JLL usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"By default, AMDGPU provides and uses JLL packages for core libraries, so as long as ld.lld is available, you should be all set for most basic functionality. For example, Julia 1.9 provides ROCm 5.2.3 libraries.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If this does not work for you, or if you have a full ROCm installation available on your system (common for HPC/supercomputer users), you can set the JULIA_AMDGPU_DISABLE_ARTIFACTS environment variable to \"1\" to disable usage of JLL artifacts:","category":"page"},{"location":"","page":"Home","title":"Home","text":"JULIA_AMDGPU_DISABLE_ARTIFACTS=1 julia --project=.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that currently ROCm-Device-Libs are always provided by AMDGPU to ensure compatibility with Julia's version of LLVM; please file an issue if this is problematic on your system.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: LLVM compatibility\nFor proper support, Julia's LLVM version should match ROCm LLVM's version. For example, Julia 1.9 relies on LLVM 14, so the matching ROCm version is 5.2.x.","category":"page"},{"location":"#Extra-Setup-Details","page":"Home","title":"Extra Setup Details","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently, the requirements to get everything working properly is a bit poorly documented in the upstream docs for any distro other than Ubuntu. So here is a list of requirements I've found through the process of making this work:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Make sure /dev/kfd has a group other than root that you can add your user to.   I recommend adding your user to the video group, and setting the   ownership of /dev/kfd to root:video with 660 permissions.\nThese libraries should be in the standard library locations, or in your LD_LIBRARY_PATH:\nlibhsakmt.so\nlibhsa-runtime64.so.1\nlibamdhip64.so\nAnd ld.lld should be in your PATH.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In terms of Linux kernel versions, just pick the newest one you can. If building your own kernel, make sure all the regular AMDGPU and HSA options are enabled.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once all of this is setup properly, you should be able to do using AMDGPU successfully. See the Quickstart documentation for an introduction to using AMDGPU.jl.","category":"page"},{"location":"#Navi-2-(GFX103x)-support","page":"Home","title":"Navi 2 (GFX103x) support","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ROCm stack officially supports only GFX1030 (6900XT). However, the ISA between GFX103x devices is nearly identical (if not identical).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Therefore, if you have any other GFX103x device, you can override your gfx version with HSA_OVERRIDE_GFX_VERSION=10.3.0 env variable before launching Julia and be able to use your device:","category":"page"},{"location":"","page":"Home","title":"Home","text":"HSA_OVERRIDE_GFX_VERSION=10.3.0 julia --project=.","category":"page"},{"location":"profiling/#rocprof","page":"Profiling","title":"rocprof","text":"","category":"section"},{"location":"profiling/","page":"Profiling","title":"Profiling","text":"rocprof allows profiling both HSA & HIP API calls.","category":"page"},{"location":"profiling/","page":"Profiling","title":"Profiling","text":"Let's profile simple copying kernel saved in profile.jl file:","category":"page"},{"location":"profiling/","page":"Profiling","title":"Profiling","text":"using AMDGPU\n\nfunction mycopy!(dst, src)\n    i = workitemIdx().x + (workgroupIdx().x - 1) * workgroupDim().x\n    if i ≤ length(dst)\n        @inbounds dst[i] = src[i]\n    end\n    return\nend\n\nfunction main(N)\n    src = ROCArray{Float64}(undef, N)\n    dst = ROCArray{Float64}(undef, N)\n    nthreads = 256\n    nblocks = cld(N, nthreads)\n\n    for i in 1:10\n        @roc groupsize=nthreads gridsize=nblocks mycopy!(dst, src)\n        AMDGPU.synchronize()\n    end\n\n    AMDGPU.unsafe_free!(dst)\n    AMDGPU.unsafe_free!(src)\n    AMDGPU.synchronize()\n    return\nend\nmain(2^24)","category":"page"},{"location":"profiling/","page":"Profiling","title":"Profiling","text":"ENABLE_JITPROFILING=1 rocprof --hip-trace --hsa-trace julia ./profile.jl","category":"page"},{"location":"profiling/","page":"Profiling","title":"Profiling","text":"This will produce results.json (among other files) which can be visualized using Perfetto UI.","category":"page"},{"location":"profiling/","page":"Profiling","title":"Profiling","text":"Zoomed out Zoomed in\n(Image: image) (Image: image)","category":"page"},{"location":"profiling/","page":"Profiling","title":"Profiling","text":"Here we can clearly see that host synchronization after each kernel dispatch causes poor device occupancy (empty spaces between kernel dispatches).","category":"page"},{"location":"profiling/","page":"Profiling","title":"Profiling","text":"We can fix this by moving synchronization outside the loop so that it happens only once.","category":"page"},{"location":"profiling/","page":"Profiling","title":"Profiling","text":"    ...\n    for i in 1:10\n        @roc groupsize=nthreads gridsize=nblocks mycopy!(dst, src)\n    end\n    AMDGPU.synchronize()\n    ...","category":"page"},{"location":"profiling/","page":"Profiling","title":"Profiling","text":"Running profiling again and visualizing results we now see that kernel launches are adjacent to each other and that the average wall duaration is lower.","category":"page"},{"location":"profiling/","page":"Profiling","title":"Profiling","text":"Zoomed out Zoomed in\n(Image: image) (Image: image)","category":"page"},{"location":"exceptions/#Kernel-Exceptions","page":"Exceptions","title":"Kernel Exceptions","text":"","category":"section"},{"location":"exceptions/","page":"Exceptions","title":"Exceptions","text":"Just like regular CPU-executed Julia functions, GPU kernels can throw exceptions!","category":"page"},{"location":"exceptions/","page":"Exceptions","title":"Exceptions","text":"For example, the following kernel will throw an out-of-bounds exception:","category":"page"},{"location":"exceptions/","page":"Exceptions","title":"Exceptions","text":"julia> using AMDGPU\n\njulia> function kerr(x)\n           x[0] = 1\n           return\n       end\nkerr (generic function with 1 method)\n\njulia> x = ROCArray([1]);\n\njulia> @roc kerr(x);\n\njulia> AMDGPU.synchronize()\nERROR: GPU Kernel Exception\nStacktrace:\n [1] error(s::String)\n   @ Base ./error.jl:35\n [2] throw_if_exception(dev::HIPDevice)\n   @ AMDGPU ~/.julia/dev/AMDGPU/src/exception_handler.jl:115\n [3] synchronize(stm::HIPStream)\n   @ AMDGPU ~/.julia/dev/AMDGPU/src/highlevel.jl:154\n [4] synchronize()\n   @ AMDGPU ~/.julia/dev/AMDGPU/src/highlevel.jl:154\n [5] top-level scope\n   @ REPL[5]:1\n\njulia> @roc kerr(x) # Next kernel launch also throws.\nERROR: GPU Kernel Exception\nStacktrace:\n [1] error(s::String)\n   @ Base ./error.jl:35\n [2] throw_if_exception(dev::HIPDevice)\n   @ AMDGPU ~/.julia/dev/AMDGPU/src/exception_handler.jl:115\n [3] #_#30\n   @ ~/.julia/dev/AMDGPU/src/runtime/hip-execution.jl:44 [inlined]\n [4] (::AMDGPU.Runtime.HIPKernel{typeof(kerr), Tuple{AMDGPU.Device.ROCDeviceVector{Int64, 1}}})(args::ROCVector{Int64})\n   @ AMDGPU.Runtime ~/.julia/dev/AMDGPU/src/runtime/hip-execution.jl:41\n [5] top-level scope\n   @ ~/.julia/dev/AMDGPU/src/highlevel.jl:228","category":"page"},{"location":"exceptions/","page":"Exceptions","title":"Exceptions","text":"Kernel-thrown exceptions are thrown during the host synchronization AMDGPU.synchronize or on the next kernel launch.","category":"page"},{"location":"exceptions/","page":"Exceptions","title":"Exceptions","text":"Kernels that hit an exception will write its information into a pre-allocated host buffer. Once complete, the wavefront throwing the exception will lock the buffer to prevent other wavefronts from overwriting the exception and stop itself, but other wavefronts will continue executing.","category":"page"}]
}
