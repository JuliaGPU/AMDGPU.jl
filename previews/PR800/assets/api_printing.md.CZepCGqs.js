import{_ as i,c as a,o as n,aj as e}from"./chunks/framework.CnxOE_Mj.js";const c=JSON.parse('{"title":"Printing","description":"","frontmatter":{},"headers":[],"relativePath":"api/printing.md","filePath":"api/printing.md","lastUpdated":null}'),t={name:"api/printing.md"};function p(l,s,h,r,k,o){return n(),a("div",null,s[0]||(s[0]=[e(`<h1 id="Printing" tabindex="-1">Printing <a class="header-anchor" href="#Printing" aria-label="Permalink to &quot;Printing {#Printing}&quot;">​</a></h1><p>Writing GPU kernels can be a difficult endeavor, owing to the fact that the LLVM GPU backends turn serial code into parallel code automatically. Recognizing this, every good GPU programming interface allows the user&#39;s GPU kernels to print output to a buffer, which will be passed to the host for display. With the ability to interpolate variables, this functionality serves as the &quot;printf of GPUs&quot;. Quite literally, the primary tool for this is <code>@rocprintf</code>. Here&#39;s a simple example of printing the current workgroup index:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kernel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> @rocprintf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Workgroup index: %d</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> workgroupIdx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x</span></span></code></pre></div><p>The above kernel would print out the string &quot;Workgroup index: 1\\n&quot; when run with a single workgroup (where &quot;\\n&quot; means a newline).</p><p>Any number of variables may be passed to <code>@rocprintf</code>, as long as those variables have a printf-compatible implementation in <code>Printf.@printf</code>. Calls to <code>@rocprintf</code> are blocking, and will not return control to the kernel until the string has been formatted and sent to the OS runtime for printing (the same as for calls to <code>Printf.@printf</code>).</p><p>While <code>@rocprintf</code> is printed once per workgroup by default, it&#39;s possible to print once per lane, once per wavefront, or once per grid by specifying an execution mode as the first argument:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Once per lane</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kernel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> @rocprintf</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :lane</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;My index is: %d</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> workitemIdx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Once per wavefront</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kernel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> @rocprintf</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :wave</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;My index is: %d</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> workitemIdx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Once per workgroup</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kernel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> @rocprintf</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :group</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;My index is: %d</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> workitemIdx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># OR (:group is the default)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kernel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> @rocprintf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;My index is: %d</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> workitemIdx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Once total</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kernel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> @rocprintf</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :grid</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;My index is: %d</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> workitemIdx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x</span></span></code></pre></div><p>Executing those kernels with 256 workitems split evenly between 2 workgroups would print out:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># :lane</span></span>
<span class="line"><span>My index is 1</span></span>
<span class="line"><span>My index is 2</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>My index is 127</span></span>
<span class="line"><span>My index is 128</span></span>
<span class="line"><span>My index is 1</span></span>
<span class="line"><span>My index is 2</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>My index is 127</span></span>
<span class="line"><span>My index is 128</span></span>
<span class="line"><span></span></span>
<span class="line"><span># :wave</span></span>
<span class="line"><span>My index is 1</span></span>
<span class="line"><span>My index is 65</span></span>
<span class="line"><span>My index is 1</span></span>
<span class="line"><span>My index is 65</span></span>
<span class="line"><span></span></span>
<span class="line"><span># :group</span></span>
<span class="line"><span>My index is 1</span></span>
<span class="line"><span>My index is 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span># :grid</span></span>
<span class="line"><span>My index is 1</span></span></code></pre></div><h2 id="Differences-to-@cuprintf" tabindex="-1">Differences to <code>@cuprintf</code> <a class="header-anchor" href="#Differences-to-@cuprintf" aria-label="Permalink to &quot;Differences to \`@cuprintf\` {#Differences-to-@cuprintf}&quot;">​</a></h2><p>Similar to CUDA&#39;s <code>@cuprintf</code>, <code>@rocprintf</code> is a printf-compatible macro which takes a format string and arguments, and commands the host CPU to display it as formatted text. However, in contrast to <code>@cuprintf</code>, we use AMDGPU&#39;s hostcall and Julia&#39;s <code>Printf</code> stdlib to implement this. This means that anything that <code>Printf</code> can print, so can <code>@rocprintf</code> (assuming such an object can be represented on the GPU). The macro is also handled as a regular hostcall, which means that argument types are checked at compile time (although currently, any errors while printing will be detected on the host, and will terminate the kernel).</p>`,11)]))}const g=i(t,[["render",p]]);export{c as __pageData,g as default};
