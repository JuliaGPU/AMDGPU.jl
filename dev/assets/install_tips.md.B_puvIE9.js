import{_ as i,c as a,o as s,az as t}from"./chunks/framework.Djr8EDGF.js";const u=JSON.parse('{"title":"Installation Info","description":"","frontmatter":{},"headers":[],"relativePath":"install_tips.md","filePath":"install_tips.md","lastUpdated":null}'),n={name:"install_tips.md"};function o(l,e,r,d,c,p){return s(),a("div",null,e[0]||(e[0]=[t(`<h1 id="Installation-Info" tabindex="-1">Installation Info <a class="header-anchor" href="#Installation-Info" aria-label="Permalink to &quot;Installation Info {#Installation-Info}&quot;">​</a></h1><h2 id="Windows-OS-missing-functionality" tabindex="-1">Windows OS missing functionality <a class="header-anchor" href="#Windows-OS-missing-functionality" aria-label="Permalink to &quot;Windows OS missing functionality {#Windows-OS-missing-functionality}&quot;">​</a></h2><p>Windows <strong>does not</strong> yet support <a href="/dev/api/hostcall#Hostcall">Hostcall</a>, which means that some of the functionality does not work, like:</p><ul><li><p>device printing;</p></li><li><p>dynamic memory allocation (from kernels).</p></li></ul><p>These hostcalls are sometimes launched when AMDGPU detects that a kernel might throw an exception, specifically during conversions, like: <code>Int32(1f0)</code>.</p><p>To avoid this, use &#39;unsafe&#39; conversion option: <code>unsafe_trunc(Int32, 1f0)</code>.</p><h2 id="ROCm-system-libraries" tabindex="-1">ROCm system libraries <a class="header-anchor" href="#ROCm-system-libraries" aria-label="Permalink to &quot;ROCm system libraries {#ROCm-system-libraries}&quot;">​</a></h2><p>AMDGPU.jl looks into standard directories and uses <code>Libdl.find_library</code> to find ROCm libraries.</p><p>Standard path:</p><ul><li><p>Linux: <code>/opt/rocm</code></p></li><li><p>Windows: <code>C:/Program Files/AMD/ROCm/&lt;rocm-version&gt;</code></p></li></ul><p>If you have non-standard path for ROCm, set <code>ROCM_PATH=&lt;path&gt;</code> environment variable before launching Julia. For example, if ROCm is installed in your Linux system root (e.g. on Fedora), set <code>ROCM_PATH=/usr/lib64/rocm/gfx11</code> or <code>ROCM_PATH=/usr/lib64/rocm/gfx1103</code>, depending on your GPU&#39;s architecture. You can query the architecture using the <code>amdgpu-arch</code> command. The <code>AMDGPU.versioninfo()</code> function prints the paths of any libraries found.</p><p>Depending on your GPU model and the functionality you want to use, you may have to force the GPU architecture by setting the <code>HSA_OVERRIDE_GFX_VERSION</code> variable to a compatible version.</p><h2 id="Extra-Setup-Details" tabindex="-1">Extra Setup Details <a class="header-anchor" href="#Extra-Setup-Details" aria-label="Permalink to &quot;Extra Setup Details {#Extra-Setup-Details}&quot;">​</a></h2><p>List of additional steps that may be needed to take to ensure everything is working:</p><ul><li><p>Make sure your user is in the same group as <code>/dev/kfd</code>, other than <code>root</code>. For example, it might be the <code>render</code> group: <code>crw-rw---- 1 root render 234, 0 Aug 5 11:43 kfd</code> In this case, you can add yourself to it: <code>sudo usermod -aG render username</code></p></li><li><p>ROCm libraries should be in the standard library locations, or in your <code>LD_LIBRARY_PATH</code>.</p></li><li><p>If you get an error message along the lines of <code>GLIB_CXX_... not found</code>, it&#39;s possible that the C++ runtime used to build the ROCm stack and the one used by Julia are different. If you built the ROCm stack yourself this is very likely the case since Julia normally ships with its own C++ runtime. For more information, check out this <a href="https://github.com/JuliaLang/julia/issues/34276" target="_blank" rel="noreferrer">GitHub issue</a>. A quick fix is to use the <code>LD_PRELOAD</code> environment variable to make Julia use the system C++ runtime library, for example: <code>LD_PRELOAD=/usr/lib/libstdc++.so julia</code> Alternatively, you can build Julia from source as described <a href="https://github.com/JuliaLang/julia/blob/master/doc/build/build.md" target="_blank" rel="noreferrer">here</a>. To quickly debug this issue start Julia and try to load a ROCm library: <code>using Libdl Libdl.dlopen(&quot;/opt/rocm/hsa/lib/libhsa-runtime64.so.1&quot;)</code></p></li></ul><p>Once all of this is setup properly, you should be able to do <code>using AMDGPU</code> successfully.</p><p>See the <a href="/dev/tutorials/index#Quick-Start">Quick Start</a> documentation for an introduction to using AMDGPU.jl.</p><h2 id="preferences" tabindex="-1">Preferences <a class="header-anchor" href="#preferences" aria-label="Permalink to &quot;Preferences&quot;">​</a></h2><p>AMDGPU.jl supports setting <a href="https://github.com/JuliaPackaging/Preferences.jl" target="_blank" rel="noreferrer">preferences</a>. Template of <code>LocalPreferences.toml</code> with all options:</p><div class="language-toml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">toml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">AMDGPU</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># If \`true\` (default), eagerly run GC to keep the pool from growing too big.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># GC is triggered during new allocatoins or synchronization points.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">eager_gc = </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Use non-blocking synchronization for all \`AMDGPU.synchronize()\` calls.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">nonblocking_synchronization = </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Memory limit specifies maximum amount of memory in percentages</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># a current Julia process can use.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Default is &quot;none&quot;, which does not apply any limitation.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">hard_memory_limit = </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;none&quot;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Notice a space between the value and percentage sign.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># hard_memory_limit = &quot;80 %&quot;</span></span></code></pre></div>`,20)]))}const m=i(n,[["render",o]]);export{u as __pageData,m as default};
