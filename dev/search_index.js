var documenterSearchIndex = {"docs":
[{"location":"execution_control/#Execution-Control-and-Intrinsics","page":"Execution Control","title":"Execution Control and Intrinsics","text":"","category":"section"},{"location":"execution_control/","page":"Execution Control","title":"Execution Control","text":"GPU execution is similar to CPU execution in some ways, although there are many differences. AMD GPUs have Compute Units (CUs), which can be thought of like CPU cores. Those CUs have (on pre-Navi architectures) 64 \"shader processors\", which are essentially the same as CPU SIMD lanes. The lanes in a CU operate in lockstep just like CPU SIMD lanes, and have execution masks and various kinds of SIMD instructions available. CUs execute wavefronts, which are pieces of work split off from a single kernel launch. A single CU can run one out of many wavefronts (one is chosen by the CU scheduler each cycle), which allows for very efficient parallel and concurrent execution on the device. Each wavefront runs independently of the other wavefronts, only stopping to synchronize with other wavefronts or terminate when specified by the program.","category":"page"},{"location":"execution_control/","page":"Execution Control","title":"Execution Control","text":"We can control wavefront execution through a variety of intrinsics provided by ROCm. For example, the endpgm() intrinsic stops the current wavefront's execution, and is also automatically inserted by the compiler at the end of each kernel (except in certain unique cases).","category":"page"},{"location":"execution_control/","page":"Execution Control","title":"Execution Control","text":"signal_completion(x) signals the \"kernel doorbell\" with the value x, which is the signal checked by the CPU wait call to determine when the kernel has completed. This doorbell is set to 0 automatically by GPU hardware once the kernel is complete.","category":"page"},{"location":"execution_control/","page":"Execution Control","title":"Execution Control","text":"sendmsg(x,y=0) and sendmsghalt(x,y=0) can be used to signal special conditions to the scheduler/hardware, such as making requests to stop wavefront generation, or halt all running wavefronts. Check the ISA manual for details!","category":"page"},{"location":"devices/#Devices","page":"Devices","title":"Devices","text":"","category":"section"},{"location":"devices/","page":"Devices","title":"Devices","text":"In AMDGPU, all GPU devices are auto-detected by the runtime, if they're supported.","category":"page"},{"location":"devices/","page":"Devices","title":"Devices","text":"AMDGPU maintains a global default device. The default device is relevant for all kernel and GPUArray operations. If one is not specified via @roc or an equivalent interface, then the default device is used for those operations, which affects compilation and kernel launch.","category":"page"},{"location":"devices/","page":"Devices","title":"Devices","text":"The device bound to a current Julia task is accessible via AMDGPU.device(). The list of available devices can be queried with AMDGPU.devices.","category":"page"},{"location":"devices/","page":"Devices","title":"Devices","text":"If you have a HIPDevice object, you can also switch the device with AMDGPU.device!. This will switch it only within the task it is called from.","category":"page"},{"location":"devices/","page":"Devices","title":"Devices","text":"xd1 = AMDGPU.ones(Float32, 16) # On `AMDGPU.device()` device.\n\nAMDGPU.device!(AMDGPU.devices()[2]) # Switch to second device.\nxd2 = AMDPGU.ones(Float32, 16) # On second device.","category":"page"},{"location":"devices/","page":"Devices","title":"Devices","text":"Additionally, devices have an associated numeric ID. This value is bounded between 1 and length(AMDGPU.devices()), and device 1 is the default device when AMDGPU is first loaded. The ID of the device associated with the current task can be queried with AMDGPU.device_id and changed with AMDGPU.device_id!.","category":"page"},{"location":"devices/","page":"Devices","title":"Devices","text":"AMDGPU.devices\nAMDGPU.device\nAMDGPU.device!\nAMDGPU.device_id\nAMDGPU.device_id!","category":"page"},{"location":"devices/#AMDGPU.devices","page":"Devices","title":"AMDGPU.devices","text":"devices()\n\nGet list of all devices.\n\n\n\n\n\n","category":"function"},{"location":"devices/#AMDGPU.device","page":"Devices","title":"AMDGPU.device","text":"device()::HIPDevice\n\nGet currently active device. This device is used when launching kernels via @roc.\n\n\n\n\n\ndevice(A::ROCArray) -> HIPDevice\n\nReturn the device associated with the array A.\n\n\n\n\n\n","category":"function"},{"location":"devices/#AMDGPU.device!","page":"Devices","title":"AMDGPU.device!","text":"device!(device::HIPDevice)\n\nSwitch current device being used. This switches only for a task inside which it is called.\n\n\n\n\n\n","category":"function"},{"location":"devices/#AMDGPU.device_id","page":"Devices","title":"AMDGPU.device_id","text":"device_id() -> Int\ndevice_id(device::HIPDevice) -> Int\n\nReturns the numerical device ID for device or for the current AMDGPU.device().\n\n\n\n\n\n","category":"function"},{"location":"devices/#AMDGPU.device_id!","page":"Devices","title":"AMDGPU.device_id!","text":"device_id!(idx::Integer)\n\nSets the current device to AMDGPU.devices()[idx]. See device_id for details on the numbering semantics.\n\n\n\n\n\n","category":"function"},{"location":"hostcall/#Hostcall","page":"Host-Call","title":"Hostcall","text":"","category":"section"},{"location":"hostcall/","page":"Host-Call","title":"Host-Call","text":"Hostcalls provide a means for GPU-CPU communications within running kernels.","category":"page"},{"location":"hostcall/","page":"Host-Call","title":"Host-Call","text":"AMDGPU.jl provides its own implementation of hostcalls, relying on HSA signals. Currently, hostcalls are used for device-side allocations, printing and exception reporting.","category":"page"},{"location":"hostcall/","page":"Host-Call","title":"Host-Call","text":"Some of the hostcalls (global hostcalls), are launched automatically, if their usage is detected during compilation (e.g. device-side allocations, exception reporting).","category":"page"},{"location":"hostcall/","page":"Host-Call","title":"Host-Call","text":"Hostcalls require careful usage, since they each spawn their own Tasks. There should be no blocking operations during this time.","category":"page"},{"location":"hostcall/","page":"Host-Call","title":"Host-Call","text":"For example, using non-blocking synchronization instead of blocking with AMDGPU.synchronize(; blocking=false) (which is also the default).","category":"page"},{"location":"hostcall/","page":"Host-Call","title":"Host-Call","text":"To stop hostcalls after synchronization, provide stop_hostcalls=true keyword argument, otherwise the performance might degarde because of constant pooling of HSA signals in a loop.","category":"page"},{"location":"hostcall/#Example","page":"Host-Call","title":"Example","text":"","category":"section"},{"location":"hostcall/","page":"Host-Call","title":"Host-Call","text":"hc = Device.HostCallHolder(Float32, Tuple{Float32}) do x\n    return x + 42f0\nend\n\nfunction kernel!(y, hc)\n    y[1] = Device.hostcall!(hc, y[1])\n    return\nend\n\ny = ROCArray(Float32[0f0])\n@roc kernel!(y, hc)\nAMDGPU.synchronize(; stop_hostcalls=true) # Stop hostcall.\n\n@assert Array(y)[1] â‰ˆ 42f0","category":"page"},{"location":"hostcall/","page":"Host-Call","title":"Host-Call","text":"In this example, HostCallHolder is used to create and launch HostCall. HostCallHolder contains the HostCall structure itself that is passed to kernel, a task that is spawned on creation and some additional info for controlling the lifetime of the task.","category":"page"},{"location":"hostcall/","page":"Host-Call","title":"Host-Call","text":"First argument is a function we want to execute when we call the hostcall. In this case we add 42f0 to input argument x and return the result.","category":"page"},{"location":"hostcall/","page":"Host-Call","title":"Host-Call","text":"Second and third arguments are the return type Float32 and the tuple of types of input arguments Tuple{Float32}.","category":"page"},{"location":"hostcall/","page":"Host-Call","title":"Host-Call","text":"hostcall! is used to execute the function on the host, wait on the result, and obtain the return values. At the moment, it is performed once per workgroup.","category":"page"},{"location":"hostcall/#Continuous-Host-Call","page":"Host-Call","title":"Continuous Host-Call","text":"","category":"section"},{"location":"hostcall/","page":"Host-Call","title":"Host-Call","text":"By default, hostcalls can be used only once. After executing the function on the host, the task finishes and exits.","category":"page"},{"location":"hostcall/","page":"Host-Call","title":"Host-Call","text":"However, if you need your hostcall to live indefinitely, pass continuous=true keyword argument to HostCallHolder(...; continuous=true).","category":"page"},{"location":"hostcall/","page":"Host-Call","title":"Host-Call","text":"To then stop the hostcall, call Device.non_continuous!(hc) or Device.finish!(hc) on the HostCallHolder.","category":"page"},{"location":"hostcall/","page":"Host-Call","title":"Host-Call","text":"The difference between them is that non_continuous! will allow calling hostcall one more time before exiting, while finish! will exit immediately.","category":"page"},{"location":"hostcall/","page":"Host-Call","title":"Host-Call","text":"finish! can be used on any HostCallHolder to force-exit the running hostcall task.","category":"page"},{"location":"logging/#Runtime-and-Compiler-Logging","page":"Logging","title":"Runtime and Compiler Logging","text":"","category":"section"},{"location":"logging/","page":"Logging","title":"Logging","text":"AMDGPU.jl has a built-in logging system integrated into various runtime and compiler operations, which is provided by TimespanLogging.jl. Operations such as compilation and linking, signal and buffer allocation/freeing, kernel launch, etc. are instrumented with logging statements, allowing the user to record the start and end of operations.","category":"page"},{"location":"logging/","page":"Logging","title":"Logging","text":"While disabled by default, logging can be enabled by first running AMDGPU.Runtime.enable_logging!() to globally enable logging, after which Julia must be restarted for the changes to take effect.","category":"page"},{"location":"logging/","page":"Logging","title":"Logging","text":"Once logging is globally enabled, AMDGPU.Runtime.start_logging() causes new log events to be saved, while AMDGPU.Runtime.stop_logging() causes new log events to be discarded. Log events can be collected with AMDGPU.Runtime.fetch_logs!(). A more convenient option is AMDGPU.Runtime.log_and_fetch!(f), which can be used to easily log operations within a region of code:","category":"page"},{"location":"logging/","page":"Logging","title":"Logging","text":"logs = AMDGPU.Runtime.log_and_fetch!() do\n    A = AMDGPU.ones(3, 4)\n    B = copy(A)\n    fill!(B, 1f0)\n    C = Array(B)\nend\n@show logs[1]","category":"page"},{"location":"api/#AMDGPU-API-Reference","page":"API Reference","title":"AMDGPU API Reference","text":"","category":"section"},{"location":"api/#Indexing","page":"API Reference","title":"Indexing","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"AMDGPU.workitemIdx\nAMDGPU.workgroupIdx\nAMDGPU.workgroupDim\nAMDGPU.gridItemDim\nAMDGPU.gridGroupDim","category":"page"},{"location":"api/#AMDGPU.Device.workitemIdx","page":"API Reference","title":"AMDGPU.Device.workitemIdx","text":"workitemIdx()::ROCDim3\n\nReturns the work item index within the work group. See also: threadIdx\n\n\n\n\n\n","category":"function"},{"location":"api/#AMDGPU.Device.workgroupIdx","page":"API Reference","title":"AMDGPU.Device.workgroupIdx","text":"workgroupIdx()::ROCDim3\n\nReturns the work group index. See also: blockIdx\n\n\n\n\n\n","category":"function"},{"location":"api/#AMDGPU.Device.workgroupDim","page":"API Reference","title":"AMDGPU.Device.workgroupDim","text":"workgroupDim()::ROCDim3\n\nReturns the size of each workgroup in workitems. See also: blockDim\n\n\n\n\n\n","category":"function"},{"location":"api/#AMDGPU.Device.gridItemDim","page":"API Reference","title":"AMDGPU.Device.gridItemDim","text":"gridItemDim()::ROCDim3\n\nReturns the size of the grid in workitems. This behaviour is different from CUDA where gridDim gives the size of the grid in blocks.\n\n\n\n\n\n","category":"function"},{"location":"api/#AMDGPU.Device.gridGroupDim","page":"API Reference","title":"AMDGPU.Device.gridGroupDim","text":"gridGroupDim()::ROCDim3\n\nReturns the size of the grid in workgroups. This is equivalent to CUDA's gridDim.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Use these functions for compatibility with CUDA.jl.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"AMDGPU.Device.threadIdx\nAMDGPU.Device.blockIdx\nAMDGPU.Device.blockDim","category":"page"},{"location":"api/#AMDGPU.Device.threadIdx","page":"API Reference","title":"AMDGPU.Device.threadIdx","text":"threadIdx()::ROCDim3\n\nReturns the thread index within the block. See also: workitemIdx\n\n\n\n\n\n","category":"function"},{"location":"api/#AMDGPU.Device.blockIdx","page":"API Reference","title":"AMDGPU.Device.blockIdx","text":"blockIdx()::ROCDim3\n\nReturns the block index within the grid. See also: workgroupIdx\n\n\n\n\n\n","category":"function"},{"location":"api/#AMDGPU.Device.blockDim","page":"API Reference","title":"AMDGPU.Device.blockDim","text":"blockDim()::ROCDim3\n\nReturns the dimensions of the block. See also: workgroupDim\n\n\n\n\n\n","category":"function"},{"location":"api/#Synchronization","page":"API Reference","title":"Synchronization","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"AMDGPU.sync_workgroup\nAMDGPU.sync_workgroup_count\nAMDGPU.sync_workgroup_and\nAMDGPU.sync_workgroup_or","category":"page"},{"location":"api/#AMDGPU.Device.sync_workgroup","page":"API Reference","title":"AMDGPU.Device.sync_workgroup","text":"sync_workgroup()\n\nWaits until all wavefronts in a workgroup have reached this call.\n\n\n\n\n\n","category":"function"},{"location":"api/#AMDGPU.Device.sync_workgroup_count","page":"API Reference","title":"AMDGPU.Device.sync_workgroup_count","text":"sync_workgroup_count(predicate::Cint)::Cint\n\nIdentical to sync_workgroup, with the additional feature that it evaluates the predicate for all workitems in the workgroup and returns the number of workitems for which predicate evaluates to non-zero.\n\n\n\n\n\n","category":"function"},{"location":"api/#AMDGPU.Device.sync_workgroup_and","page":"API Reference","title":"AMDGPU.Device.sync_workgroup_and","text":"sync_workgroup_and(predicate::Cint)::Cint\n\nIdentical to sync_workgroup, with the additional feature that it evaluates the predicate for all workitems in the workgroup and returns non-zero if and only if predicate evaluates to non-zero for all of them.\n\n\n\n\n\n","category":"function"},{"location":"api/#AMDGPU.Device.sync_workgroup_or","page":"API Reference","title":"AMDGPU.Device.sync_workgroup_or","text":"sync_workgroup_or(predicate::Cint)::Cint\n\nIdentical to sync_workgroup, with the additional feature that it evaluates the predicate for all workitems in the workgroup and returns non-zero if and only if predicate evaluates to non-zero for any of them.\n\n\n\n\n\n","category":"function"},{"location":"kernel_launch/#Kernel-Launch","page":"Kernel Launch","title":"Kernel Launch","text":"","category":"section"},{"location":"kernel_launch/#Launch-Configuration","page":"Kernel Launch","title":"Launch Configuration","text":"","category":"section"},{"location":"kernel_launch/","page":"Kernel Launch","title":"Kernel Launch","text":"While an almost arbitrarily large number of workitems can be executed per kernel launch, the hardware can only support executing a limited number of wavefronts at one time.","category":"page"},{"location":"kernel_launch/","page":"Kernel Launch","title":"Kernel Launch","text":"To alleviate this, the compiler calculates the \"occupancy\" of each compiled kernel (which is the number of wavefronts that can be simultaneously executing on the GPU), and passes this information to the hardware; the hardware then launches a limited number of wavefronts at once, based on the kernel's \"occupancy\" values.","category":"page"},{"location":"kernel_launch/","page":"Kernel Launch","title":"Kernel Launch","text":"The rest of the wavefronts are not launched until hardware resources become available, which means that a kernel with better occupancy will see more of its wavefronts executing simultaneously (which often leads to better performance). Suffice to say, it's important to know the occupancy of kernels if you want the best performance.","category":"page"},{"location":"kernel_launch/","page":"Kernel Launch","title":"Kernel Launch","text":"Like CUDA.jl, AMDGPU.jl has the ability to calculate kernel occupancy, with the launch_configuration function:","category":"page"},{"location":"kernel_launch/","page":"Kernel Launch","title":"Kernel Launch","text":"kernel = @roc launch=false mykernel(args...)\noccupancy = AMDGPU.launch_configuration(kernel)\n@show occupancy.gridsize\n@show occupancy.groupsize","category":"page"},{"location":"kernel_launch/","page":"Kernel Launch","title":"Kernel Launch","text":"Specifically, launch_configuration calculates the occupancy of mykernel(args...), and then calculates an optimal groupsize based on the occupancy. This value can then be used to select the groupsize for the kernel:","category":"page"},{"location":"kernel_launch/","page":"Kernel Launch","title":"Kernel Launch","text":"@roc groupsize=occupancy.groupsize mykernel(args...)","category":"page"},{"location":"quickstart/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quickstart/#Running-a-simple-kernel","page":"Quick Start","title":"Running a simple kernel","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"As a simple test, we will try to add two random vectors and make sure that the results from the CPU and the GPU are indeed the same.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"We can start by first performing this simple calculation on the CPU:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"N = 1024\na = rand(Float64, N)\nb = rand(Float64, N)\nc_cpu = a + b","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"To do the same computation on the GPU, we first need to copy the two input arrays a and b to the device. Toward that end, we will use the ROCArray type to represent our GPU arrays. We can create the two arrays by passing the host data to the constructor as follows:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"using AMDGPU\na_d = ROCArray(a)\nb_d = ROCArray(b)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"We need to create one additional array c_d to store the results:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"c_d = similar(a_d)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"In this example, the postfix _d distinguishes a device memory object from its host memory counterpart. This convention is completely arbitrary and you may name your device-side variables whatever you like; they are regular Julia variables.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Next, we will define the GPU kernel that does the actual computation:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"function vadd!(c, a, b)\n    i = workitemIdx().x + (workgroupIdx().x - 1) * workgroupDim().x\n    c[i] = a[i] + b[i]\n    return\nend","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"The index of a single workitem can be uniquely identified by its grid index (computed linearly as (workgroupDim().x * (workgroupIdx().x - 1)) + workitemIdx().x when only a single dimension is used).","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"The grid is the domain over which the entire kernel executes over. The grid will be split into multiple workgroups by hardware automatically, and the kernel does not complete until all workgroups complete.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Like OpenCL, AMDGPU has the concept of \"workitems\", \"workgroups\", and the \"grid\". A workitem is a single thread of execution, capable of performing arithmentic operations. Workitems are grouped into \"wavefronts\" (\"warps\" in CUDA) which share the same compute unit, and execute the same instructions simulatenously. The workgroup is a logical unit of compute supported by hardware which comprises multiple wavefronts, which shares resources (specifically local memory) and can be efficiently synchronized. A workgroup may be executed by one or multiple hardware compute units, making it often the only dimension of importance for smaller kernel launches.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Notice how we explicitly specify that this function does not return a value by adding the return statement. This is necessary for all GPU kernels and we can enforce it by adding a return, return nothing, or even nothing at the end of the kernel. If this statement is omitted, Julia will attempt to return the value of the last evaluated expression, in this case a Float64, which will cause a compilation failure as kernels cannot return values.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"The easiest way to launch a GPU kernel is with the @roc macro, specifying groupsize and gridsize to cover full array, and calling it like a regular function:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"groupsize = 128\ngridsize = cld(length(c_d), groupsize)\n@roc gridsize=gridsize groupsize=groupsize vadd!(c_d, a_d, b_d)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Keep in mind that kernel launches are asynchronous, meaning that you need to do some kind of synchronization before you use the result. For instance, you can call AMDGPU.synchronize():","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"@roc groupsize=N vadd!(c_d, a_d, b_d)\nAMDGPU.synchronize()","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Finally, we can make sure that the results match, by first copying the data to the host and then comparing it with the CPU results:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"c = Array(c_d)\n\nusing Test\n@test isapprox(c, c_cpu)","category":"page"},{"location":"quickstart/#Naming-conventions","page":"Quick Start","title":"Naming conventions","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Throughout this example we use terms like \"work group\" and \"work item\". These terms are used by the Khronos consortium and their APIs including OpenCL and Vulkan, as well as the HSA foundation.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"NVIDIA, on the other hand, uses some different terms in their CUDA API, which might be confusing to some users porting their kernels from CUDA to AMDGPU.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"As a quick summary, here is a mapping of the most common terms:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"AMDGPU CUDA\nworkitemIdx threadIdx\nworkgroupIdx blockIdx\nworkgroupDim blockDim\ngridItemDim No equivalent\ngridGroupDim gridDim\ngroupsize threads\ngridsize blocks\nstream stream","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"warning: Warning\nSince AMDGPU v0.5.0 gridsize represents the number of \"workgroups\" (or blocks in CUDA) and no longer \"workitems * workgroups\" (or threads * blocks in CUDA).","category":"page"},{"location":"memory/#Memory-Allocation-and-Intrinsics","page":"Memory","title":"Memory Allocation and Intrinsics","text":"","category":"section"},{"location":"memory/#Memory-Varieties","page":"Memory","title":"Memory Varieties","text":"","category":"section"},{"location":"memory/","page":"Memory","title":"Memory","text":"GPUs contain various kinds of memory, just like CPUs:","category":"page"},{"location":"memory/","page":"Memory","title":"Memory","text":"Global:   Globally accessible by all CUs on a GPU, and possibly accessible   from outside of the GPU (by the CPU host, by other GPUs, by PCIe devices,   etc.). Slowest form of memory.\nConstant:   Same as global memory, but signals to the hardware that it can use   special instructions to access and cache this memory.   Can be changed between kernel invocations.\nRegion:   Also known as Global Data Store (GDS), all wavefronts on a CU   can access the same memory region from the same address.   Faster than Global/Constant.   Automatically allocated by the compiler/runtime, not user accessible.\nLocal:   Also known as Local Data Store (LDS), all wavefronts in the same workgroup   can access the same memory region from the same address.   Faster than GDS.\nPrivate:   Uses the hardware scratch space, and is private to each SIMD lane   in a wavefront.   Fastest form of traditional memory.","category":"page"},{"location":"memory/#Local-Memory","page":"Memory","title":"Local Memory","text":"","category":"section"},{"location":"memory/","page":"Memory","title":"Memory","text":"Local memory may be allocated within a kernel by calling either:","category":"page"},{"location":"memory/","page":"Memory","title":"Memory","text":"@ROCStaticLocalArray(T, dims) - if dims is passed as a constant value,   known at compile-time.   E.g. @ROCStaticLocalArray(Float32, 8).\n@ROCDynamicLocalArray(T, dims) - otherwise.   E.g. @ROCStaticLocalArray(Float32, length(X)).","category":"page"},{"location":"memory/","page":"Memory","title":"Memory","text":"Local memory is zero-initialized by default. If this is unnecessary and undesired for performance reasons, disable this, passing false as a last argument: @ROCStaticLocalArray(Float32, 8, false) or @ROCStaticLocalArray(Float32, length(X), false)","category":"page"},{"location":"memory/","page":"Memory","title":"Memory","text":"Local memory does not need to be freed, as it is automatically freed by the hardware.","category":"page"},{"location":"memory/","page":"Memory","title":"Memory","text":"If @ROCDynamicLocalArray is used, then local memory is dynamically allocated at kernel execution time. The shmem option to @roc must be set appropriately to ensure that enough local memory is allocated by the hardware.","category":"page"},{"location":"memory/","page":"Memory","title":"Memory","text":"It is allocated in addition to the local memory that is statically allocated by the kernel.","category":"page"},{"location":"memory/","page":"Memory","title":"Memory","text":"function kernel(C, A)\n    # Allocate local memory dynamically\n    Ctmp = @ROCDynamicLocalArray(Float64, length(C))\n    # Or, allocate local memory statically if the size is known ahead-of-time\n    Ctmp = @ROCStaticLocalArray(Float64, 8) # if we want 8 elements\n\n    idx = AMDGPU.workitemIdx().x\n    Ctmp[idx] = A[idx] + C[1]\n    AMDGPU.Device.sync_workgroup()\n\n    C[idx] = Ctmp[idx]\n    return\nend\n\n...\n# Note: The `shmem` option isn't necessary if `@ROCStaticLocalArray` is used\nshmem = sizeof(Float64) * length(RC)\n@roc groupsize=8 shmem=shmem kernel(RC, RA)","category":"page"},{"location":"memory/#Device-Side-Allocations","page":"Memory","title":"Device-Side Allocations","text":"","category":"section"},{"location":"memory/","page":"Memory","title":"Memory","text":"Global memory may be allocated/freed dynamically from kernels by calling AMDGPU.Device.malloc(::Csize_t)::Ptr{Cvoid} and AMDGPU.Device.free(::Ptr{Cvoid}).","category":"page"},{"location":"memory/","page":"Memory","title":"Memory","text":"This memory allocation/deallocation uses hostcalls to operate, and so is relatively slow, but is also very useful. See Hostcall section for more info about them.","category":"page"},{"location":"memory/","page":"Memory","title":"Memory","text":"Memory allocated with AMDGPU.Device.malloc is a host-pinned memory. Calls to malloc and free are performed once per workgroup, so ensure that enough memory has been allocated to feed the lanes that will be accessing it.","category":"page"},{"location":"memory/","page":"Memory","title":"Memory","text":"As an example, here's how an array could be allocated on-device to store temporary results:","category":"page"},{"location":"memory/","page":"Memory","title":"Memory","text":"function kernel(C, A)\n    # Allocate memory dynamically and get a pointer to it.\n    Ctmp_ptr = AMDGPU.Device.malloc(Csize_t(sizeof(Float64) * length(C)))\n    # Turn a pointer into a device-side array.\n    Ctmp = ROCDeviceArray(length(C), reinterpret(Core.LLVMPtr{Float64,1}, Ctmp_ptr))\n\n    # Use it\n    idx = AMDGPU.workitemIdx().x\n    Ctmp[idx] = A[idx] + C[1]\n    AMDGPU.Device.sync_workgroup()\n\n    C[idx] = Ctmp[idx]\n    # Make sure to free it.\n    AMDGPU.Device.free(Ctmp_ptr)\n    return\nend\n\nRA = AMDGPU.rand(4)\nRC = AMDGPU.rand(4)\nRC_elem = Array(RC)[1]\n@roc groupsize=4 kernel(RC, RA)\n@assert Array(RC) â‰ˆ Array(RA) .+ RC_elem","category":"page"},{"location":"memory/#Memory-Modification-Intrinsics","page":"Memory","title":"Memory Modification Intrinsics","text":"","category":"section"},{"location":"memory/","page":"Memory","title":"Memory","text":"Like C, AMDGPU.jl provides the memset! and memcpy! intrinsics, which are useful for setting a memory region to a value, or copying one region to another, respectively. Check test/device/memory.jl for examples of their usage.","category":"page"},{"location":"memory/#Wrapping-in-ROCArray","page":"Memory","title":"Wrapping in ROCArray","text":"","category":"section"},{"location":"memory/","page":"Memory","title":"Memory","text":"You can wrap host array to be accessible (pinned) on the device with:","category":"page"},{"location":"memory/","page":"Memory","title":"Memory","text":"x = rand(Float32, 4, 4)\nxd = unsafe_wrap(ROCArray, pointer(x), size(x))\n\n# Pointer to `xd` is a device-mapped pointer, not host pointer.\n@show pointer(xd) == xd.buf.dev_ptr\n@show pointer(xd) == xd.buf.ptr\n\n# Can be used in kernels, host array `x` is also updated.\nxd .+= 1f0\n\n# Can be used with HIP libraries.\nxd * xd","category":"page"},{"location":"memory/","page":"Memory","title":"Memory","text":"Pinned memory is automatically unregistered upon array destruction. You can't free it, since it is managed by the host.","category":"page"},{"location":"memory/","page":"Memory","title":"Memory","text":"Additionally, you can wrap the device array with:","category":"page"},{"location":"memory/","page":"Memory","title":"Memory","text":"x = AMDGPU.rand(Float32, 4, 4)\nxd = unsafe_wrap(ROCArray, pointer(x), size(x); lock=false)\n\n# Can be used in kernels, `x` is also updated.\nxd .+= 1f0\n\n# Can be used with HIP libraries.\nxd * xd\n\n# Freeing is a no-op for `xd`, since `xd` does not own the underlying memory.\nAMDGPU.unsafe_free!(xd) # No-op.","category":"page"},{"location":"memory/","page":"Memory","title":"Memory","text":"Notice mandatory ; lock=false keyword, this is to be able to differentiate between host & device pointers.","category":"page"},{"location":"printing/#Printing","page":"Printing","title":"Printing","text":"","category":"section"},{"location":"printing/","page":"Printing","title":"Printing","text":"Writing GPU kernels can be a difficult endeavor, owing to the fact that the LLVM GPU backends turn serial code into parallel code automatically. Recognizing this, every good GPU programming interface allows the user's GPU kernels to print output to a buffer, which will be passed to the host for display. With the ability to interpolate variables, this functionality serves as the \"printf of GPUs\". Quite literally, the primary tool for this is @rocprintf. Here's a simple example of printing the current workgroup index:","category":"page"},{"location":"printing/","page":"Printing","title":"Printing","text":"kernel(x) = @rocprintf \"Workgroup index: %d\\n\" workgroupIdx().x","category":"page"},{"location":"printing/","page":"Printing","title":"Printing","text":"The above kernel would print out the string \"Workgroup index: 1\\n\" when run with a single workgroup (where \"\\n\" means a newline).","category":"page"},{"location":"printing/","page":"Printing","title":"Printing","text":"Any number of variables may be passed to @rocprintf, as long as those variables have a printf-compatible implementation in Printf.@printf. Calls to @rocprintf are blocking, and will not return control to the kernel until the string has been formatted and sent to the OS runtime for printing (the same as for calls to Printf.@printf).","category":"page"},{"location":"printing/","page":"Printing","title":"Printing","text":"While @rocprintf is printed once per workgroup by default, it's possible to print once per lane, once per wavefront, or once per grid by specifying an execution mode as the first argument:","category":"page"},{"location":"printing/","page":"Printing","title":"Printing","text":"# Once per lane\nkernel(x) = @rocprintf :lane \"My index is: %d\\n\" workitemIdx().x\n\n# Once per wavefront\nkernel(x) = @rocprintf :wave \"My index is: %d\\n\" workitemIdx().x\n\n# Once per workgroup\nkernel(x) = @rocprintf :group \"My index is: %d\\n\" workitemIdx().x\n# OR (:group is the default)\nkernel(x) = @rocprintf \"My index is: %d\\n\" workitemIdx().x\n\n# Once total\nkernel(x) = @rocprintf :grid \"My index is: %d\\n\" workitemIdx().x","category":"page"},{"location":"printing/","page":"Printing","title":"Printing","text":"Executing those kernels with 256 workitems split evenly between 2 workgroups would print out:","category":"page"},{"location":"printing/","page":"Printing","title":"Printing","text":"# :lane\nMy index is 1\nMy index is 2\n...\nMy index is 127\nMy index is 128\nMy index is 1\nMy index is 2\n...\nMy index is 127\nMy index is 128\n\n# :wave\nMy index is 1\nMy index is 65\nMy index is 1\nMy index is 65\n\n# :group\nMy index is 1\nMy index is 1\n\n# :grid\nMy index is 1","category":"page"},{"location":"printing/#Differences-to-@cuprintf","page":"Printing","title":"Differences to @cuprintf","text":"","category":"section"},{"location":"printing/","page":"Printing","title":"Printing","text":"Similar to CUDA's @cuprintf, @rocprintf is a printf-compatible macro which takes a format string and arguments, and commands the host CPU to display it as formatted text. However, in contrast to @cuprintf, we use AMDGPU's hostcall and Julia's Printf stdlib to implement this. This means that anything that Printf can print, so can @rocprintf (assuming such an object can be represented on the GPU). The macro is also handled as a regular hostcall, which means that argument types are checked at compile time (although currently, any errors while printing will be detected on the host, and will terminate the kernel).","category":"page"},{"location":"streams/#Streams","page":"Streams","title":"Streams","text":"","category":"section"},{"location":"streams/","page":"Streams","title":"Streams","text":"Similar to CUDA streams, ROCm has HIP streams, which are buffers used to instruct the GPU hardware which kernels to launch. HIP streams are synchronous, like CUDA streams.","category":"page"},{"location":"streams/","page":"Streams","title":"Streams","text":"Each device has a default stream associated, which is accessible with AMDGPU.stream().","category":"page"},{"location":"streams/","page":"Streams","title":"Streams","text":"There are several ways to specify which stream to launch a kernel on:","category":"page"},{"location":"streams/","page":"Streams","title":"Streams","text":"Using AMDGPU.stream! to change default stream to be used   within the same Julia task.","category":"page"},{"location":"streams/","page":"Streams","title":"Streams","text":"stream = AMDGPU.HIPStream()\nAMDGPU.stream!(stream) # Change default stream to be used for subsequent operations.\nAMDGPU.ones(Float32, 16) # Will be executed on `stream`.","category":"page"},{"location":"streams/","page":"Streams","title":"Streams","text":"Using AMDGPU.stream! to execute given function and reset   to the original stream after completion:","category":"page"},{"location":"streams/","page":"Streams","title":"Streams","text":"stream = AMDGPU.HIPStream()\nx = AMDGPU.stream!(() -> AMDGPU.ones(Float32, 16), stream)","category":"page"},{"location":"streams/","page":"Streams","title":"Streams","text":"Using stream argument to @roc macro:","category":"page"},{"location":"streams/","page":"Streams","title":"Streams","text":"stream = AMDGPU.HIPStream()\n@roc stream=stream kernel(...)","category":"page"},{"location":"streams/","page":"Streams","title":"Streams","text":"Streams also have an inherent priority, which allows control of kernel submission latency and on-device scheduling preference with respect to kernels submitted on other streams. There are three priorities: normal (the default), low, and high priority.","category":"page"},{"location":"streams/","page":"Streams","title":"Streams","text":"Priority of the default stream can be set with AMDGPU.priority!. Alternatively, it can be set at stream creation time:","category":"page"},{"location":"streams/","page":"Streams","title":"Streams","text":"low_prio = HIPStream(:low)\nhigh_prio = HIPStream(:high)\nnormal_prio = HIPStream(:normal) # or just omit \"priority\"","category":"page"},{"location":"streams/","page":"Streams","title":"Streams","text":"AMDGPU.stream\nAMDGPU.stream!\nAMDGPU.priority!\nAMDGPU.HIPStream","category":"page"},{"location":"streams/#AMDGPU.stream","page":"Streams","title":"AMDGPU.stream","text":"stream()::HIPStream\n\nGet the HIP stream that should be used as the default one for the currently executing task.\n\n\n\n\n\n","category":"function"},{"location":"streams/#AMDGPU.stream!","page":"Streams","title":"AMDGPU.stream!","text":"stream!(s::HIPStream)\n\nChange the default stream to be used within the same Julia task.\n\n\n\n\n\nstream!(f::Base.Callable, stream::HIPStream)\n\nChange the default stream to be used within the same Julia task, execute f and revert to the original stream.\n\nReturns:\n\nReturn value of the function f.\n\n\n\n\n\n","category":"function"},{"location":"streams/#AMDGPU.priority!","page":"Streams","title":"AMDGPU.priority!","text":"priority!(p::Symbol)\n\nChange the priority of the default stream. Accepted values are :normal (the default), :low and :high.\n\n\n\n\n\npriority!(f::Base.Callable, priority::Symbol)\n\nChnage the priority of default stream, execute f and revert to the original priority. Accepted values are :normal (the default), :low and :high.\n\nReturns:\n\nReturn value of the function f.\n\n\n\n\n\n","category":"function"},{"location":"streams/#AMDGPU.HIP.HIPStream","page":"Streams","title":"AMDGPU.HIP.HIPStream","text":"HIPStream(priority::Symbol = :normal)\n\nArguments:\n\npriority::Symbol: Priority of the stream: :normal, :high or :low.\n\nCreate HIPStream with given priority. Device is the default device that's currently in use.\n\n\n\n\n\nHIPStream(stream::hipStream_t)\n\nCreate HIPStream from hipStream_t handle. Device is the default device that's currently in use.\n\n\n\n\n\n","category":"type"},{"location":"streams/#Synchronization","page":"Streams","title":"Synchronization","text":"","category":"section"},{"location":"streams/","page":"Streams","title":"Streams","text":"AMDGPU.jl by default uses non-blocking stream synchronization with AMDGPU.synchronize to work correctly with TLS and Hostcall.","category":"page"},{"location":"streams/","page":"Streams","title":"Streams","text":"Users, however, can switch to a blocking synchronization globally with nonblocking_synchronization preference or with fine-grained AMDGPU.synchronize(; blocking=true). Blocking synchronization might offer slightly lower latency.","category":"page"},{"location":"streams/","page":"Streams","title":"Streams","text":"You can also perform synchroization of the expression with AMDGPU.@sync macro, which will execute given expression and synchronize afterwards (using AMDGPU.synchronize under the hood).","category":"page"},{"location":"streams/","page":"Streams","title":"Streams","text":"AMDGPU.@sync begin\n    @roc ...\nend","category":"page"},{"location":"streams/","page":"Streams","title":"Streams","text":"Finally, you can perform full device synchronization with AMDGPU.device_synchronize.","category":"page"},{"location":"streams/","page":"Streams","title":"Streams","text":"AMDGPU.synchronize\nAMDGPU.@sync\nAMDGPU.device_synchronize","category":"page"},{"location":"streams/#AMDGPU.synchronize","page":"Streams","title":"AMDGPU.synchronize","text":"synchronize(stream::HIPStream = stream(); blocking::Bool = false)\n\nWait until all kernels executing on stream have completed.\n\nIf there are running HostCalls, then blocking must be false. Additionally, if you want to stop host calls afterwards, then provide stop_hostcalls=true keyword argument.\n\n\n\n\n\n","category":"function"},{"location":"streams/#AMDGPU.@sync","page":"Streams","title":"AMDGPU.@sync","text":"@sync ex\n\nRun expression ex on currently active stream and synchronize the GPU on that stream afterwards.\n\nSee also: synchronize.\n\n\n\n\n\n","category":"macro"},{"location":"streams/#AMDGPU.device_synchronize","page":"Streams","title":"AMDGPU.device_synchronize","text":"Blocks until all kernels on all streams have completed. Uses currently active device.\n\n\n\n\n\n","category":"function"},{"location":"#Programming-AMD-GPUs-with-Julia","page":"Home","title":"Programming AMD GPUs with Julia","text":"","category":"section"},{"location":"#The-Julia-AMDGPU-stack","page":"Home","title":"The Julia AMDGPU stack","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia support for programming AMD GPUs is currently provided by the AMDGPU.jl package. This package contains everything necessary to program for AMD GPUs in Julia, including:","category":"page"},{"location":"","page":"Home","title":"Home","text":"An interface for compiling and running kernels written in Julia through LLVM's AMDGPU backend.\nAn interface for working with the HIP runtime API,   necessary for launching compiled kernels and controlling the GPU.\nAn array type implementing the GPUArrays.jl   interface, providing high-level array operations.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Simply add the AMDGPU.jl package to your Julia environment:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"AMDGPU\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To ensure that everything works, you can run the test suite:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using AMDGPU\nusing Pkg\nPkg.test(\"AMDGPU\")","category":"page"},{"location":"#Requirements","page":"Home","title":"Requirements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia 1.9 or higher.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Minimal supported ROCm version is 5.3. However, if you have ROCm 5.5+ installed, refer to LLVM compatibility & mixed ROCm mode section for additional instructions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For optimal experience, you should have full ROCm stack installed. Refer to official ROCm stack installation instructions: https://rocm.docs.amd.com/en/latest/deploy/linux/index.html","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently, AMDGPU.jl utilizes following libraries:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ROCT, ROCR, ROCm-Device-Libs, HIP, rocBLAS, rocFFT, rocSOLVER, rocSPARSE, rocRAND, MIOpen.","category":"page"},{"location":"#ROCm-artifacts","page":"Home","title":"ROCm artifacts","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There is limited support for ROCm 5.4+ artifacts which can be enabled with AMDGPU.enable_artifacts!.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Limited means not all libraries are available and some of the functionality may be disabled.","category":"page"},{"location":"","page":"Home","title":"Home","text":"AMDGPU.enable_artifacts!","category":"page"},{"location":"#AMDGPU.ROCmDiscovery.enable_artifacts!","page":"Home","title":"AMDGPU.ROCmDiscovery.enable_artifacts!","text":"enable_artifacts!(flag::Bool = true)\n\nPass true to switch from system-wide ROCm installtion to artifacts. When using artifacts, system-wide installation is not needed at all.\n\n\n\n\n\n","category":"function"},{"location":"#LLVM-compatibility-and-mixed-ROCm-mode","page":"Home","title":"LLVM compatibility & mixed ROCm mode","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As a rule of thumb, Julia LLVM version should match ROCm LLVM version. For example Julia 1.10 uses LLVM 15, but ROCm 5.5+ uses LLVM 16 which are incompatible.","category":"page"},{"location":"","page":"Home","title":"Home","text":"However, there is a way to run system ROCm 5.5+ with Julia:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Add respective version of artifact device libraries in your project:\nROCm 5.5: ]add ROCmDeviceLibs_jll@5.5;\nROCm 5.6: ]add ROCmDeviceLibs_jll@5.6.\nCall AMDGPU.use_devlibs_jll! in your Julia session to switch  to artifact device libraries (and the rest of the libraries  will be used from system-wide installation).","category":"page"},{"location":"","page":"Home","title":"Home","text":"AMDGPU.use_devlibs_jll!","category":"page"},{"location":"#AMDGPU.ROCmDiscovery.use_devlibs_jll!","page":"Home","title":"AMDGPU.ROCmDiscovery.use_devlibs_jll!","text":"use_devlibs_jll!(flag::Bool = true)\n\nPass true to use device libraries from artifacts and the rest of the libraries from system-wide ROCm installation (mixed-mode).\n\nThis allows using ROCm 5.5+ which internally uses LLVM 16+, but device libraries from artifacts are built with LLVM 15 which makes them compatible with Julia.\n\n\n\n\n\n","category":"function"},{"location":"#Extra-Setup-Details","page":"Home","title":"Extra Setup Details","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"List of additional steps that may be needed to take to ensure everything is working:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Make sure your user is in the same group as /dev/kfd, other than root.\nFor example, it might be the render group:\ncrw-rw----   1 root   render  234,   0 Aug  5 11:43 kfd\nIn this case, you can add yourself to it:\nsudo usermod -aG render username\nROCm libraries should be in the standard library locations, or in your LD_LIBRARY_PATH.\nIf you get an error message along the lines of GLIB_CXX_... not found,   it's possible that the C++ runtime used to build the ROCm stack   and the one used by Julia are different.   If you built the ROCm stack yourself this is very likely the case   since Julia normally ships with its own C++ runtime.\nFor more information, check out this GitHub issue.   A quick fix is to use the LD_PRELOAD environment variable to make Julia use the system C++ runtime library, for example:\nLD_PRELOAD=/usr/lib/libstdc++.so julia\nAlternatively, you can build Julia from source as described   here.   To quickly debug this issue start Julia and try to load a ROCm library:\nusing Libdl   Libdl.dlopen(\"/opt/rocm/hsa/lib/libhsa-runtime64.so.1\")\nld.lld should be in your PATH.\nFor better experience use whatever Linux kernel   is officially supported by ROCm stack.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once all of this is setup properly, you should be able to do using AMDGPU successfully.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the Quick Start documentation for an introduction to using AMDGPU.jl.","category":"page"},{"location":"#Preferences","page":"Home","title":"Preferences","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AMDGPU.jl supports setting preferences. Template of LocalPreferences.toml with all options:","category":"page"},{"location":"","page":"Home","title":"Home","text":"[AMDGPU]\n# If `true` then use ROCm libraries provided by artifacts.\n# However, not all ROCm libraries are available as artifacts.\nuse_artifacts = false\n# Use mixed-mode ROCm. This will use device libraries from artifacts,\n# but the rest of the ROCm libraries from system-wide installation.\n# See `LLVM compatibility & mixed ROCm mode` section in the documentation.\nuse_devlibs_jll = false\n# Use non-blocking synchronization for all `AMDGPU.synchronize()` calls.\nnonblocking_synchronization = true\n# Memory limit specifies maximum amount of memory in percentages\n# a current Julia process can use.\n# Default is \"none\", which does not apply any limitation.\nhard_memory_limit = \"none\"\n# Notice a space between the value and percentage sign.\n# hard_memory_limit = \"80 %\"","category":"page"},{"location":"profiling/#rocprof","page":"Profiling","title":"rocprof","text":"","category":"section"},{"location":"profiling/","page":"Profiling","title":"Profiling","text":"rocprof allows profiling both HSA & HIP API calls.","category":"page"},{"location":"profiling/","page":"Profiling","title":"Profiling","text":"Let's profile simple copying kernel saved in profile.jl file:","category":"page"},{"location":"profiling/","page":"Profiling","title":"Profiling","text":"using AMDGPU\n\nfunction mycopy!(dst, src)\n    i = workitemIdx().x + (workgroupIdx().x - 1) * workgroupDim().x\n    if i â‰¤ length(dst)\n        @inbounds dst[i] = src[i]\n    end\n    return\nend\n\nfunction main(N)\n    src = ROCArray{Float64}(undef, N)\n    dst = ROCArray{Float64}(undef, N)\n    groupsize = 256               # nthreads\n    gridsize = cld(N, groupsize)  # nblocks\n\n    for i in 1:10\n        @roc groupsize=groupsize gridsize=gridsize mycopy!(dst, src)\n        AMDGPU.synchronize()\n    end\n\n    AMDGPU.unsafe_free!(dst)\n    AMDGPU.unsafe_free!(src)\n    AMDGPU.synchronize()\n    return\nend\nmain(2^24)","category":"page"},{"location":"profiling/","page":"Profiling","title":"Profiling","text":"ENABLE_JITPROFILING=1 rocprof --hip-trace --hsa-trace julia ./profile.jl","category":"page"},{"location":"profiling/","page":"Profiling","title":"Profiling","text":"This will produce results.json (among other files) which can be visualized using Perfetto UI.","category":"page"},{"location":"profiling/","page":"Profiling","title":"Profiling","text":"Zoomed out Zoomed in\n(Image: image) (Image: image)","category":"page"},{"location":"profiling/","page":"Profiling","title":"Profiling","text":"Here we can clearly see that host synchronization after each kernel dispatch causes poor device occupancy (empty spaces between kernel dispatches).","category":"page"},{"location":"profiling/","page":"Profiling","title":"Profiling","text":"We can fix this by moving synchronization outside the loop so that it happens only once.","category":"page"},{"location":"profiling/","page":"Profiling","title":"Profiling","text":"    ...\n    for i in 1:10\n        @roc groupsize=groupsize gridsize=gridsize mycopy!(dst, src)\n    end\n    AMDGPU.synchronize()\n    ...","category":"page"},{"location":"profiling/","page":"Profiling","title":"Profiling","text":"Running profiling again and visualizing results we now see that kernel launches are adjacent to each other and that the average wall duaration is lower.","category":"page"},{"location":"profiling/","page":"Profiling","title":"Profiling","text":"Zoomed out Zoomed in\n(Image: image) (Image: image)","category":"page"},{"location":"exceptions/#Kernel-Exceptions","page":"Exceptions","title":"Kernel Exceptions","text":"","category":"section"},{"location":"exceptions/","page":"Exceptions","title":"Exceptions","text":"Just like regular CPU-executed Julia functions, GPU kernels can throw exceptions!","category":"page"},{"location":"exceptions/","page":"Exceptions","title":"Exceptions","text":"For example, the following kernel will throw an out-of-bounds exception:","category":"page"},{"location":"exceptions/","page":"Exceptions","title":"Exceptions","text":"julia> using AMDGPU\n\njulia> function kerr(x)\n           x[0] = 1\n           return\n       end\nkerr (generic function with 1 method)\n\njulia> x = ROCArray([1]);\n\njulia> @roc kerr(x);\n\njulia> AMDGPU.synchronize()\nERROR: GPU Kernel Exception\nStacktrace:\n [1] error(s::String)\n   @ Base ./error.jl:35\n [2] throw_if_exception(dev::HIPDevice)\n   @ AMDGPU ~/.julia/dev/AMDGPU/src/exception_handler.jl:115\n [3] synchronize(stm::HIPStream)\n   @ AMDGPU ~/.julia/dev/AMDGPU/src/highlevel.jl:154\n [4] synchronize()\n   @ AMDGPU ~/.julia/dev/AMDGPU/src/highlevel.jl:154\n [5] top-level scope\n   @ REPL[5]:1\n\njulia> @roc kerr(x) # Next kernel launch also throws.\nERROR: GPU Kernel Exception\nStacktrace:\n [1] error(s::String)\n   @ Base ./error.jl:35\n [2] throw_if_exception(dev::HIPDevice)\n   @ AMDGPU ~/.julia/dev/AMDGPU/src/exception_handler.jl:115\n [3] #_#30\n   @ ~/.julia/dev/AMDGPU/src/runtime/hip-execution.jl:44 [inlined]\n [4] (::AMDGPU.Runtime.HIPKernel{typeof(kerr), Tuple{AMDGPU.Device.ROCDeviceVector{Int64, 1}}})(args::ROCVector{Int64})\n   @ AMDGPU.Runtime ~/.julia/dev/AMDGPU/src/runtime/hip-execution.jl:41\n [5] top-level scope\n   @ ~/.julia/dev/AMDGPU/src/highlevel.jl:228","category":"page"},{"location":"exceptions/","page":"Exceptions","title":"Exceptions","text":"Kernel-thrown exceptions are thrown during the host synchronization AMDGPU.synchronize or on the next kernel launch.","category":"page"},{"location":"exceptions/","page":"Exceptions","title":"Exceptions","text":"Kernels that hit an exception will write its information into a pre-allocated host buffer. Once complete, the wavefront throwing the exception will lock the buffer to prevent other wavefronts from overwriting the exception and stop itself, but other wavefronts will continue executing.","category":"page"}]
}
